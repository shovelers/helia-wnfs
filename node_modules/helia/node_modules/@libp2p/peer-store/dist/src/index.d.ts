import type { Libp2pEvents } from '@libp2p/interface';
import type { TypedEventTarget } from '@libp2p/interface/events';
import type { PeerId } from '@libp2p/interface/peer-id';
import type { PeerStore, Peer, PeerData, PeerQuery } from '@libp2p/interface/peer-store';
import type { Multiaddr } from '@multiformats/multiaddr';
import type { Datastore } from 'interface-datastore';
export interface PersistentPeerStoreComponents {
    peerId: PeerId;
    datastore: Datastore;
    events: TypedEventTarget<Libp2pEvents>;
}
/**
 * Return true to allow storing the passed multiaddr for the passed peer
 */
export interface AddressFilter {
    (peerId: PeerId, multiaddr: Multiaddr): Promise<boolean>;
}
export interface PersistentPeerStoreInit {
    addressFilter?: AddressFilter;
}
/**
 * An implementation of PeerStore that stores data in a Datastore
 */
export declare class PersistentPeerStore implements PeerStore {
    #private;
    private readonly store;
    private readonly events;
    private readonly peerId;
    constructor(components: PersistentPeerStoreComponents, init?: PersistentPeerStoreInit);
    forEach(fn: (peer: Peer) => void, query?: PeerQuery): Promise<void>;
    all(query?: PeerQuery): Promise<Peer[]>;
    delete(peerId: PeerId): Promise<void>;
    has(peerId: PeerId): Promise<boolean>;
    get(peerId: PeerId): Promise<Peer>;
    save(id: PeerId, data: PeerData): Promise<Peer>;
    patch(id: PeerId, data: PeerData): Promise<Peer>;
    merge(id: PeerId, data: PeerData): Promise<Peer>;
    consumePeerRecord(buf: Uint8Array, expectedPeer?: PeerId): Promise<boolean>;
}
//# sourceMappingURL=index.d.ts.map