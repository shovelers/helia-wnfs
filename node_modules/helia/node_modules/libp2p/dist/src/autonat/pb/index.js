/* eslint-disable import/export */
/* eslint-disable complexity */
/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime';
export var Message;
(function (Message) {
    let MessageType;
    (function (MessageType) {
        MessageType["DIAL"] = "DIAL";
        MessageType["DIAL_RESPONSE"] = "DIAL_RESPONSE";
    })(MessageType = Message.MessageType || (Message.MessageType = {}));
    let __MessageTypeValues;
    (function (__MessageTypeValues) {
        __MessageTypeValues[__MessageTypeValues["DIAL"] = 0] = "DIAL";
        __MessageTypeValues[__MessageTypeValues["DIAL_RESPONSE"] = 1] = "DIAL_RESPONSE";
    })(__MessageTypeValues || (__MessageTypeValues = {}));
    (function (MessageType) {
        MessageType.codec = () => {
            return enumeration(__MessageTypeValues);
        };
    })(MessageType = Message.MessageType || (Message.MessageType = {}));
    let ResponseStatus;
    (function (ResponseStatus) {
        ResponseStatus["OK"] = "OK";
        ResponseStatus["E_DIAL_ERROR"] = "E_DIAL_ERROR";
        ResponseStatus["E_DIAL_REFUSED"] = "E_DIAL_REFUSED";
        ResponseStatus["E_BAD_REQUEST"] = "E_BAD_REQUEST";
        ResponseStatus["E_INTERNAL_ERROR"] = "E_INTERNAL_ERROR";
    })(ResponseStatus = Message.ResponseStatus || (Message.ResponseStatus = {}));
    let __ResponseStatusValues;
    (function (__ResponseStatusValues) {
        __ResponseStatusValues[__ResponseStatusValues["OK"] = 0] = "OK";
        __ResponseStatusValues[__ResponseStatusValues["E_DIAL_ERROR"] = 100] = "E_DIAL_ERROR";
        __ResponseStatusValues[__ResponseStatusValues["E_DIAL_REFUSED"] = 101] = "E_DIAL_REFUSED";
        __ResponseStatusValues[__ResponseStatusValues["E_BAD_REQUEST"] = 200] = "E_BAD_REQUEST";
        __ResponseStatusValues[__ResponseStatusValues["E_INTERNAL_ERROR"] = 300] = "E_INTERNAL_ERROR";
    })(__ResponseStatusValues || (__ResponseStatusValues = {}));
    (function (ResponseStatus) {
        ResponseStatus.codec = () => {
            return enumeration(__ResponseStatusValues);
        };
    })(ResponseStatus = Message.ResponseStatus || (Message.ResponseStatus = {}));
    let PeerInfo;
    (function (PeerInfo) {
        let _codec;
        PeerInfo.codec = () => {
            if (_codec == null) {
                _codec = message((obj, w, opts = {}) => {
                    if (opts.lengthDelimited !== false) {
                        w.fork();
                    }
                    if (obj.id != null) {
                        w.uint32(10);
                        w.bytes(obj.id);
                    }
                    if (obj.addrs != null) {
                        for (const value of obj.addrs) {
                            w.uint32(18);
                            w.bytes(value);
                        }
                    }
                    if (opts.lengthDelimited !== false) {
                        w.ldelim();
                    }
                }, (reader, length) => {
                    const obj = {
                        addrs: []
                    };
                    const end = length == null ? reader.len : reader.pos + length;
                    while (reader.pos < end) {
                        const tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                obj.id = reader.bytes();
                                break;
                            case 2:
                                obj.addrs.push(reader.bytes());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return obj;
                });
            }
            return _codec;
        };
        PeerInfo.encode = (obj) => {
            return encodeMessage(obj, PeerInfo.codec());
        };
        PeerInfo.decode = (buf) => {
            return decodeMessage(buf, PeerInfo.codec());
        };
    })(PeerInfo = Message.PeerInfo || (Message.PeerInfo = {}));
    let Dial;
    (function (Dial) {
        let _codec;
        Dial.codec = () => {
            if (_codec == null) {
                _codec = message((obj, w, opts = {}) => {
                    if (opts.lengthDelimited !== false) {
                        w.fork();
                    }
                    if (obj.peer != null) {
                        w.uint32(10);
                        Message.PeerInfo.codec().encode(obj.peer, w);
                    }
                    if (opts.lengthDelimited !== false) {
                        w.ldelim();
                    }
                }, (reader, length) => {
                    const obj = {};
                    const end = length == null ? reader.len : reader.pos + length;
                    while (reader.pos < end) {
                        const tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                obj.peer = Message.PeerInfo.codec().decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return obj;
                });
            }
            return _codec;
        };
        Dial.encode = (obj) => {
            return encodeMessage(obj, Dial.codec());
        };
        Dial.decode = (buf) => {
            return decodeMessage(buf, Dial.codec());
        };
    })(Dial = Message.Dial || (Message.Dial = {}));
    let DialResponse;
    (function (DialResponse) {
        let _codec;
        DialResponse.codec = () => {
            if (_codec == null) {
                _codec = message((obj, w, opts = {}) => {
                    if (opts.lengthDelimited !== false) {
                        w.fork();
                    }
                    if (obj.status != null) {
                        w.uint32(8);
                        Message.ResponseStatus.codec().encode(obj.status, w);
                    }
                    if (obj.statusText != null) {
                        w.uint32(18);
                        w.string(obj.statusText);
                    }
                    if (obj.addr != null) {
                        w.uint32(26);
                        w.bytes(obj.addr);
                    }
                    if (opts.lengthDelimited !== false) {
                        w.ldelim();
                    }
                }, (reader, length) => {
                    const obj = {};
                    const end = length == null ? reader.len : reader.pos + length;
                    while (reader.pos < end) {
                        const tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                obj.status = Message.ResponseStatus.codec().decode(reader);
                                break;
                            case 2:
                                obj.statusText = reader.string();
                                break;
                            case 3:
                                obj.addr = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return obj;
                });
            }
            return _codec;
        };
        DialResponse.encode = (obj) => {
            return encodeMessage(obj, DialResponse.codec());
        };
        DialResponse.decode = (buf) => {
            return decodeMessage(buf, DialResponse.codec());
        };
    })(DialResponse = Message.DialResponse || (Message.DialResponse = {}));
    let _codec;
    Message.codec = () => {
        if (_codec == null) {
            _codec = message((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if (obj.type != null) {
                    w.uint32(8);
                    Message.MessageType.codec().encode(obj.type, w);
                }
                if (obj.dial != null) {
                    w.uint32(18);
                    Message.Dial.codec().encode(obj.dial, w);
                }
                if (obj.dialResponse != null) {
                    w.uint32(26);
                    Message.DialResponse.codec().encode(obj.dialResponse, w);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length) => {
                const obj = {};
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            obj.type = Message.MessageType.codec().decode(reader);
                            break;
                        case 2:
                            obj.dial = Message.Dial.codec().decode(reader, reader.uint32());
                            break;
                        case 3:
                            obj.dialResponse = Message.DialResponse.codec().decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    Message.encode = (obj) => {
        return encodeMessage(obj, Message.codec());
    };
    Message.decode = (buf) => {
        return decodeMessage(buf, Message.codec());
    };
})(Message || (Message = {}));
//# sourceMappingURL=index.js.map