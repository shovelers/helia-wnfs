import { upnpNat } from '@achingbrain/nat-port-mapper';
import { CodeError } from '@libp2p/interface/errors';
import { logger } from '@libp2p/logger';
import { isLoopback } from '@libp2p/utils/multiaddr/is-loopback';
import { fromNodeAddress } from '@multiformats/multiaddr';
import isPrivateIp from 'private-ip';
import { isBrowser } from 'wherearewe';
import { codes } from '../errors.js';
import * as pkg from '../version.js';
const log = logger('libp2p:upnp-nat');
const DEFAULT_TTL = 7200;
function highPort(min = 1024, max = 65535) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}
class UPnPNAT {
    components;
    externalAddress;
    localAddress;
    description;
    ttl;
    keepAlive;
    gateway;
    started;
    client;
    constructor(components, init) {
        this.components = components;
        this.started = false;
        this.externalAddress = init.externalAddress;
        this.localAddress = init.localAddress;
        this.description = init.description ?? `${pkg.name}@${pkg.version} ${this.components.peerId.toString()}`;
        this.ttl = init.ttl ?? DEFAULT_TTL;
        this.keepAlive = init.keepAlive ?? true;
        this.gateway = init.gateway;
        if (this.ttl < DEFAULT_TTL) {
            throw new CodeError(`NatManager ttl should be at least ${DEFAULT_TTL} seconds`, codes.ERR_INVALID_PARAMETERS);
        }
    }
    isStarted() {
        return this.started;
    }
    start() {
        // #TODO: is there a way to remove this? Seems like a hack
    }
    /**
     * Attempt to use uPnP to configure port mapping using the current gateway.
     *
     * Run after start to ensure the transport manager has all addresses configured.
     */
    afterStart() {
        if (isBrowser || this.started) {
            return;
        }
        this.started = true;
        // done async to not slow down startup
        void this._start().catch((err) => {
            // hole punching errors are non-fatal
            log.error(err);
        });
    }
    async _start() {
        const addrs = this.components.transportManager.getAddrs();
        for (const addr of addrs) {
            // try to open uPnP ports for each thin waist address
            const { family, host, port, transport } = addr.toOptions();
            if (!addr.isThinWaistAddress() || transport !== 'tcp') {
                // only bare tcp addresses
                // eslint-disable-next-line no-continue
                continue;
            }
            if (isLoopback(addr)) {
                // eslint-disable-next-line no-continue
                continue;
            }
            if (family !== 4) {
                // ignore ipv6
                // eslint-disable-next-line no-continue
                continue;
            }
            const client = this._getClient();
            const publicIp = this.externalAddress ?? await client.externalIp();
            const isPrivate = isPrivateIp(publicIp);
            if (isPrivate === true) {
                throw new Error(`${publicIp} is private - please set config.nat.externalIp to an externally routable IP or ensure you are not behind a double NAT`);
            }
            if (isPrivate == null) {
                throw new Error(`${publicIp} is not an IP address`);
            }
            const publicPort = highPort();
            log(`opening uPnP connection from ${publicIp}:${publicPort} to ${host}:${port}`);
            await client.map({
                publicPort,
                localPort: port,
                localAddress: this.localAddress,
                protocol: transport.toUpperCase() === 'TCP' ? 'TCP' : 'UDP'
            });
            this.components.addressManager.addObservedAddr(fromNodeAddress({
                family: 4,
                address: publicIp,
                port: publicPort
            }, transport));
        }
    }
    _getClient() {
        if (this.client != null) {
            return this.client;
        }
        this.client = upnpNat({
            description: this.description,
            ttl: this.ttl,
            keepAlive: this.keepAlive,
            gateway: this.gateway
        });
        return this.client;
    }
    /**
     * Stops the NAT manager
     */
    async stop() {
        if (isBrowser || this.client == null) {
            return;
        }
        try {
            await this.client.close();
            this.client = undefined;
        }
        catch (err) {
            log.error(err);
        }
    }
}
export function uPnPNATService(init = {}) {
    return (components) => {
        return new UPnPNAT(components, init);
    };
}
//# sourceMappingURL=index.js.map