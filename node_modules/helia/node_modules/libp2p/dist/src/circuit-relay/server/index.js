import { TypedEventEmitter, setMaxListeners } from '@libp2p/interface/events';
import { logger } from '@libp2p/logger';
import { peerIdFromBytes } from '@libp2p/peer-id';
import { RecordEnvelope } from '@libp2p/peer-record';
import { multiaddr } from '@multiformats/multiaddr';
import { pbStream } from 'it-protobuf-stream';
import pDefer from 'p-defer';
import { MAX_CONNECTIONS } from '../../connection-manager/constants.js';
import { CIRCUIT_PROTO_CODE, DEFAULT_HOP_TIMEOUT, RELAY_SOURCE_TAG, RELAY_V2_HOP_CODEC, RELAY_V2_STOP_CODEC } from '../constants.js';
import { HopMessage, Status, StopMessage } from '../pb/index.js';
import { createLimitedRelay } from '../utils.js';
import { AdvertService } from './advert-service.js';
import { ReservationStore } from './reservation-store.js';
import { ReservationVoucherRecord } from './reservation-voucher.js';
const log = logger('libp2p:circuit-relay:server');
const isRelayAddr = (ma) => ma.protoCodes().includes(CIRCUIT_PROTO_CODE);
const defaults = {
    maxOutboundStopStreams: MAX_CONNECTIONS
};
class CircuitRelayServer extends TypedEventEmitter {
    registrar;
    peerStore;
    addressManager;
    peerId;
    connectionManager;
    connectionGater;
    reservationStore;
    advertService;
    started;
    hopTimeout;
    shutdownController;
    maxInboundHopStreams;
    maxOutboundHopStreams;
    maxOutboundStopStreams;
    /**
     * Creates an instance of Relay
     */
    constructor(components, init = {}) {
        super();
        this.registrar = components.registrar;
        this.peerStore = components.peerStore;
        this.addressManager = components.addressManager;
        this.peerId = components.peerId;
        this.connectionManager = components.connectionManager;
        this.connectionGater = components.connectionGater;
        this.started = false;
        this.hopTimeout = init?.hopTimeout ?? DEFAULT_HOP_TIMEOUT;
        this.shutdownController = new AbortController();
        this.maxInboundHopStreams = init.maxInboundHopStreams;
        this.maxOutboundHopStreams = init.maxOutboundHopStreams;
        this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults.maxOutboundStopStreams;
        setMaxListeners(Infinity, this.shutdownController.signal);
        if (init.advertise != null && init.advertise !== false) {
            this.advertService = new AdvertService(components, init.advertise === true ? undefined : init.advertise);
            this.advertService.addEventListener('advert:success', () => {
                this.safeDispatchEvent('relay:advert:success', {});
            });
            this.advertService.addEventListener('advert:error', (evt) => {
                this.safeDispatchEvent('relay:advert:error', { detail: evt.detail });
            });
        }
        this.reservationStore = new ReservationStore(init.reservations);
    }
    isStarted() {
        return this.started;
    }
    /**
     * Start Relay service
     */
    async start() {
        if (this.started) {
            return;
        }
        // Advertise service if HOP enabled and advertising enabled
        this.advertService?.start();
        await this.registrar.handle(RELAY_V2_HOP_CODEC, (data) => {
            void this.onHop(data).catch(err => {
                log.error(err);
            });
        }, {
            maxInboundStreams: this.maxInboundHopStreams,
            maxOutboundStreams: this.maxOutboundHopStreams,
            runOnTransientConnection: true
        });
        this.reservationStore.start();
        this.started = true;
    }
    /**
     * Stop Relay service
     */
    async stop() {
        this.advertService?.stop();
        this.reservationStore.stop();
        this.shutdownController.abort();
        await this.registrar.unhandle(RELAY_V2_HOP_CODEC);
        this.started = false;
    }
    async onHop({ connection, stream }) {
        log('received circuit v2 hop protocol stream from %p', connection.remotePeer);
        const hopTimeoutPromise = pDefer();
        const timeout = setTimeout(() => {
            hopTimeoutPromise.reject('timed out');
        }, this.hopTimeout);
        const pbstr = pbStream(stream);
        try {
            const request = await Promise.race([
                pbstr.pb(HopMessage).read(),
                hopTimeoutPromise.promise
            ]);
            if (request?.type == null) {
                throw new Error('request was invalid, could not read from stream');
            }
            log('received', request.type);
            await Promise.race([
                this.handleHopProtocol({
                    connection,
                    stream: pbstr,
                    request
                }),
                hopTimeoutPromise.promise
            ]);
        }
        catch (err) {
            log.error('error while handling hop', err);
            await pbstr.pb(HopMessage).write({
                type: HopMessage.Type.STATUS,
                status: Status.MALFORMED_MESSAGE
            });
            stream.abort(err);
        }
        finally {
            clearTimeout(timeout);
        }
    }
    async handleHopProtocol({ stream, request, connection }) {
        log('received hop message');
        switch (request.type) {
            case HopMessage.Type.RESERVE:
                await this.handleReserve({ stream, request, connection });
                break;
            case HopMessage.Type.CONNECT:
                await this.handleConnect({ stream, request, connection });
                break;
            default: {
                log.error('invalid hop request type %s via peer %p', request.type, connection.remotePeer);
                await stream.pb(HopMessage).write({ type: HopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE });
            }
        }
    }
    async handleReserve({ stream, request, connection }) {
        const hopstr = stream.pb(HopMessage);
        log('hop reserve request from %p', connection.remotePeer);
        if (isRelayAddr(connection.remoteAddr)) {
            log.error('relay reservation over circuit connection denied for peer: %p', connection.remotePeer);
            await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED });
            return;
        }
        if ((await this.connectionGater.denyInboundRelayReservation?.(connection.remotePeer)) === true) {
            log.error('reservation for %p denied by connection gater', connection.remotePeer);
            await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED });
            return;
        }
        const result = this.reservationStore.reserve(connection.remotePeer, connection.remoteAddr);
        if (result.status !== Status.OK) {
            await hopstr.write({ type: HopMessage.Type.STATUS, status: result.status });
            return;
        }
        try {
            // tag relay target peer
            // result.expire is non-null if `ReservationStore.reserve` returns with status == OK
            if (result.expire != null) {
                const ttl = (result.expire * 1000) - Date.now();
                await this.peerStore.merge(connection.remotePeer, {
                    tags: {
                        [RELAY_SOURCE_TAG]: { value: 1, ttl }
                    }
                });
            }
            await hopstr.write({
                type: HopMessage.Type.STATUS,
                status: Status.OK,
                reservation: await this.makeReservation(connection.remotePeer, BigInt(result.expire ?? 0)),
                limit: this.reservationStore.get(connection.remotePeer)?.limit
            });
            log('sent confirmation response to %s', connection.remotePeer);
        }
        catch (err) {
            log.error('failed to send confirmation response to %p', connection.remotePeer, err);
            this.reservationStore.removeReservation(connection.remotePeer);
        }
    }
    async makeReservation(remotePeer, expire) {
        const addrs = [];
        for (const relayAddr of this.addressManager.getAddresses()) {
            if (relayAddr.toString().includes('/p2p-circuit')) {
                continue;
            }
            addrs.push(relayAddr.bytes);
        }
        const voucher = await RecordEnvelope.seal(new ReservationVoucherRecord({
            peer: remotePeer,
            relay: this.peerId,
            expiration: Number(expire)
        }), this.peerId);
        return {
            addrs,
            expire,
            voucher: voucher.marshal()
        };
    }
    async handleConnect({ stream, request, connection }) {
        const hopstr = stream.pb(HopMessage);
        if (isRelayAddr(connection.remoteAddr)) {
            log.error('relay reservation over circuit connection denied for peer: %p', connection.remotePeer);
            await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED });
            return;
        }
        log('hop connect request from %p', connection.remotePeer);
        let dstPeer;
        try {
            if (request.peer == null) {
                log.error('no peer info in hop connect request');
                throw new Error('no peer info in request');
            }
            request.peer.addrs.forEach(multiaddr);
            dstPeer = peerIdFromBytes(request.peer.id);
        }
        catch (err) {
            log.error('invalid hop connect request via peer %p %s', connection.remotePeer, err);
            await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE });
            return;
        }
        if (!this.reservationStore.hasReservation(dstPeer)) {
            log.error('hop connect denied for destination peer %p not having a reservation for %p with status %s', dstPeer, connection.remotePeer, Status.NO_RESERVATION);
            await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.NO_RESERVATION });
            return;
        }
        if ((await this.connectionGater.denyOutboundRelayedConnection?.(connection.remotePeer, dstPeer)) === true) {
            log.error('hop connect for %p to %p denied by connection gater', connection.remotePeer, dstPeer);
            await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED });
            return;
        }
        const connections = this.connectionManager.getConnections(dstPeer);
        if (connections.length === 0) {
            log('hop connect denied for destination peer %p not having a connection for %p as there is no destination connection', dstPeer, connection.remotePeer);
            await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.NO_RESERVATION });
            return;
        }
        const destinationConnection = connections[0];
        const destinationStream = await this.stopHop({
            connection: destinationConnection,
            request: {
                type: StopMessage.Type.CONNECT,
                peer: {
                    id: connection.remotePeer.toBytes(),
                    addrs: []
                }
            }
        });
        if (destinationStream == null) {
            log.error('failed to open stream to destination peer %p', destinationConnection?.remotePeer);
            await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.CONNECTION_FAILED });
            return;
        }
        await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.OK });
        const sourceStream = stream.unwrap();
        log('connection from %p to %p established - merging streams', connection.remotePeer, dstPeer);
        const limit = this.reservationStore.get(dstPeer)?.limit;
        // Short circuit the two streams to create the relayed connection
        createLimitedRelay(sourceStream, destinationStream, this.shutdownController.signal, limit);
    }
    /**
     * Send a STOP request to the target peer that the dialing peer wants to contact
     */
    async stopHop({ connection, request }) {
        log('starting circuit relay v2 stop request to %s', connection.remotePeer);
        const stream = await connection.newStream([RELAY_V2_STOP_CODEC], {
            maxOutboundStreams: this.maxOutboundStopStreams,
            runOnTransientConnection: true
        });
        const pbstr = pbStream(stream);
        const stopstr = pbstr.pb(StopMessage);
        await stopstr.write(request);
        let response;
        try {
            response = await stopstr.read();
        }
        catch (err) {
            log.error('error parsing stop message response from %p', connection.remotePeer);
        }
        if (response == null) {
            log.error('could not read response from %p', connection.remotePeer);
            await stream.close();
            return;
        }
        if (response.status === Status.OK) {
            log('stop request to %p was successful', connection.remotePeer);
            return pbstr.unwrap();
        }
        log('stop request failed with code %d', response.status);
        await stream.close();
    }
    get reservations() {
        return this.reservationStore.reservations;
    }
}
export function circuitRelayServer(init = {}) {
    return (components) => {
        return new CircuitRelayServer(components, init);
    };
}
//# sourceMappingURL=index.js.map