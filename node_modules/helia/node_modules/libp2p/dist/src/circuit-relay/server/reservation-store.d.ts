import { PeerMap } from '@libp2p/peer-collections';
import { type Limit, Status } from '../pb/index.js';
import type { RelayReservation } from '../index.js';
import type { RecursivePartial } from '@libp2p/interface';
import type { PeerId } from '@libp2p/interface/peer-id';
import type { Startable } from '@libp2p/interface/startable';
import type { Multiaddr } from '@multiformats/multiaddr';
export type ReservationStatus = Status.OK | Status.PERMISSION_DENIED | Status.RESERVATION_REFUSED;
export interface ReservationStoreInit {
    maxReservations?: number;
    reservationClearInterval?: number;
    applyDefaultLimit?: boolean;
    /**
     * reservation ttl, default: 2 hours
     */
    reservationTtl?: number;
    /**
     * The maximum time a relayed connection can be open for
     */
    defaultDurationLimit?: number;
    /**
     * The maximum amount of data allowed to be transferred over a relayed connection
     */
    defaultDataLimit?: bigint;
}
export type ReservationStoreOptions = RecursivePartial<ReservationStoreInit>;
export declare class ReservationStore implements Startable {
    readonly reservations: PeerMap<RelayReservation>;
    private _started;
    private interval;
    private readonly maxReservations;
    private readonly reservationClearInterval;
    private readonly applyDefaultLimit;
    private readonly reservationTtl;
    private readonly defaultDurationLimit;
    private readonly defaultDataLimit;
    constructor(options?: ReservationStoreOptions);
    isStarted(): boolean;
    start(): void;
    stop(): void;
    reserve(peer: PeerId, addr: Multiaddr, limit?: Limit): {
        status: ReservationStatus;
        expire?: number;
    };
    removeReservation(peer: PeerId): void;
    hasReservation(dst: PeerId): boolean;
    get(peer: PeerId): RelayReservation | undefined;
}
//# sourceMappingURL=reservation-store.d.ts.map