import { PeerMap } from '@libp2p/peer-collections';
import { DEFAULT_DATA_LIMIT, DEFAULT_DURATION_LIMIT, DEFAULT_MAX_RESERVATION_CLEAR_INTERVAL, DEFAULT_MAX_RESERVATION_STORE_SIZE, DEFAULT_MAX_RESERVATION_TTL } from '../constants.js';
import { Status } from '../pb/index.js';
export class ReservationStore {
    reservations = new PeerMap();
    _started = false;
    interval;
    maxReservations;
    reservationClearInterval;
    applyDefaultLimit;
    reservationTtl;
    defaultDurationLimit;
    defaultDataLimit;
    constructor(options = {}) {
        this.maxReservations = options.maxReservations ?? DEFAULT_MAX_RESERVATION_STORE_SIZE;
        this.reservationClearInterval = options.reservationClearInterval ?? DEFAULT_MAX_RESERVATION_CLEAR_INTERVAL;
        this.applyDefaultLimit = options.applyDefaultLimit !== false;
        this.reservationTtl = options.reservationTtl ?? DEFAULT_MAX_RESERVATION_TTL;
        this.defaultDurationLimit = options.defaultDurationLimit ?? DEFAULT_DURATION_LIMIT;
        this.defaultDataLimit = options.defaultDataLimit ?? DEFAULT_DATA_LIMIT;
    }
    isStarted() {
        return this._started;
    }
    start() {
        if (this._started) {
            return;
        }
        this._started = true;
        this.interval = setInterval(() => {
            const now = (new Date()).getTime();
            this.reservations.forEach((r, k) => {
                if (r.expire.getTime() < now) {
                    this.reservations.delete(k);
                }
            });
        }, this.reservationClearInterval);
    }
    stop() {
        clearInterval(this.interval);
    }
    reserve(peer, addr, limit) {
        if (this.reservations.size >= this.maxReservations && !this.reservations.has(peer)) {
            return { status: Status.RESERVATION_REFUSED };
        }
        const expire = new Date(Date.now() + this.reservationTtl);
        let checkedLimit;
        if (this.applyDefaultLimit) {
            checkedLimit = limit ?? { data: this.defaultDataLimit, duration: this.defaultDurationLimit };
        }
        this.reservations.set(peer, { addr, expire, limit: checkedLimit });
        // return expiry time in seconds
        return { status: Status.OK, expire: Math.round(expire.getTime() / 1000) };
    }
    removeReservation(peer) {
        this.reservations.delete(peer);
    }
    hasReservation(dst) {
        return this.reservations.has(dst);
    }
    get(peer) {
        return this.reservations.get(peer);
    }
}
//# sourceMappingURL=reservation-store.js.map