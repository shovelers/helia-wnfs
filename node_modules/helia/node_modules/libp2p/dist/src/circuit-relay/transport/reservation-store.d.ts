import { TypedEventEmitter, type TypedEventTarget } from '@libp2p/interface/events';
import type { Reservation } from '../pb/index.js';
import type { Libp2pEvents } from '@libp2p/interface';
import type { PeerId } from '@libp2p/interface/peer-id';
import type { PeerStore } from '@libp2p/interface/peer-store';
import type { Startable } from '@libp2p/interface/startable';
import type { ConnectionManager } from '@libp2p/interface-internal/connection-manager';
import type { TransportManager } from '@libp2p/interface-internal/transport-manager';
export interface RelayStoreComponents {
    peerId: PeerId;
    connectionManager: ConnectionManager;
    transportManager: TransportManager;
    peerStore: PeerStore;
    events: TypedEventTarget<Libp2pEvents>;
}
export interface RelayStoreInit {
    /**
     * Multiple relays may be discovered simultaneously - to prevent listening
     * on too many relays, this value controls how many to attempt to reserve a
     * slot on at once. If set to more than one, we may end up listening on
     * more relays than the `maxReservations` value, but on networks with poor
     * connectivity the user may wish to attempt to reserve on multiple relays
     * simultaneously. (default: 1)
     */
    reservationConcurrency?: number;
    /**
     * How many discovered relays to allow in the reservation store
     */
    discoverRelays?: number;
    /**
     * Limit the number of potential relays we will dial (default: 100)
     */
    maxReservationQueueLength?: number;
    /**
     * When creating a reservation it must complete within this number of ms
     * (default: 5000)
     */
    reservationCompletionTimeout?: number;
}
export type RelayType = 'discovered' | 'configured';
export interface ReservationStoreEvents {
    'relay:not-enough-relays': CustomEvent;
    'relay:removed': CustomEvent<PeerId>;
}
export declare class ReservationStore extends TypedEventEmitter<ReservationStoreEvents> implements Startable {
    #private;
    private readonly peerId;
    private readonly connectionManager;
    private readonly transportManager;
    private readonly peerStore;
    private readonly events;
    private readonly reserveQueue;
    private readonly reservations;
    private readonly maxDiscoveredRelays;
    private readonly maxReservationQueueLength;
    private readonly reservationCompletionTimeout;
    private started;
    constructor(components: RelayStoreComponents, init?: RelayStoreInit);
    isStarted(): boolean;
    start(): Promise<void>;
    stop(): Promise<void>;
    /**
     * If the number of current relays is beneath the configured `maxReservations`
     * value, and the passed peer id is not our own, and we have a non-relayed connection
     * to the remote, and the remote peer speaks the hop protocol, try to reserve a slot
     * on the remote peer
     */
    addRelay(peerId: PeerId, type: RelayType): Promise<void>;
    hasReservation(peerId: PeerId): boolean;
    getReservation(peerId: PeerId): Reservation | undefined;
}
//# sourceMappingURL=reservation-store.d.ts.map