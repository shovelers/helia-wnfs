import { TypedEventEmitter } from '@libp2p/interface/events';
import { logger } from '@libp2p/logger';
import { RELAY_RENDEZVOUS_NS, RELAY_V2_HOP_CODEC } from '../constants.js';
import { namespaceToCid } from '../utils.js';
const log = logger('libp2p:circuit-relay:discover-relays');
/**
 * ReservationManager automatically makes a circuit v2 reservation on any connected
 * peers that support the circuit v2 HOP protocol.
 */
export class RelayDiscovery extends TypedEventEmitter {
    peerId;
    peerStore;
    contentRouting;
    registrar;
    started;
    topologyId;
    constructor(components) {
        super();
        this.started = false;
        this.peerId = components.peerId;
        this.peerStore = components.peerStore;
        this.contentRouting = components.contentRouting;
        this.registrar = components.registrar;
    }
    isStarted() {
        return this.started;
    }
    async start() {
        // register a topology listener for when new peers are encountered
        // that support the hop protocol
        this.topologyId = await this.registrar.register(RELAY_V2_HOP_CODEC, {
            notifyOnTransient: true,
            onConnect: (peerId) => {
                this.safeDispatchEvent('relay:discover', { detail: peerId });
            }
        });
        void this.discover()
            .catch(err => {
            log.error('error listening on relays', err);
        });
        this.started = true;
    }
    stop() {
        if (this.topologyId != null) {
            this.registrar.unregister(this.topologyId);
        }
        this.started = false;
    }
    /**
     * Try to listen on available hop relay connections.
     * The following order will happen while we do not have enough relays:
     *
     * 1. Check the metadata store for known relays, try to listen on the ones we are already connected
     * 2. Dial and try to listen on the peers we know that support hop but are not connected
     * 3. Search the network
     */
    async discover() {
        log('searching peer store for relays');
        const peers = (await this.peerStore.all({
            filters: [
                // filter by a list of peers supporting RELAY_V2_HOP and ones we are not listening on
                (peer) => {
                    return peer.protocols.includes(RELAY_V2_HOP_CODEC);
                }
            ],
            orders: [
                () => Math.random() < 0.5 ? 1 : -1
            ]
        }));
        for (const peer of peers) {
            log('found relay peer %p in content peer store', peer.id);
            this.safeDispatchEvent('relay:discover', { detail: peer.id });
        }
        log('found %d relay peers in peer store', peers.length);
        try {
            log('searching content routing for relays');
            const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
            let found = 0;
            for await (const provider of this.contentRouting.findProviders(cid)) {
                if (provider.multiaddrs.length > 0 && !provider.id.equals(this.peerId)) {
                    const peerId = provider.id;
                    found++;
                    await this.peerStore.merge(peerId, {
                        multiaddrs: provider.multiaddrs
                    });
                    log('found relay peer %p in content routing', peerId);
                    this.safeDispatchEvent('relay:discover', { detail: peerId });
                }
            }
            log('found %d relay peers in content routing', found);
        }
        catch (err) {
            log.error('failed when finding relays on the network', err);
        }
    }
}
//# sourceMappingURL=discovery.js.map