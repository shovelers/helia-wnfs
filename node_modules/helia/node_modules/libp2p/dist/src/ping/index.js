import { randomBytes } from '@libp2p/crypto';
import { CodeError } from '@libp2p/interface/errors';
import { logger } from '@libp2p/logger';
import first from 'it-first';
import { pipe } from 'it-pipe';
import { equals as uint8ArrayEquals } from 'uint8arrays/equals';
import { codes } from '../errors.js';
import { PROTOCOL_PREFIX, PROTOCOL_NAME, PING_LENGTH, PROTOCOL_VERSION, TIMEOUT, MAX_INBOUND_STREAMS, MAX_OUTBOUND_STREAMS } from './constants.js';
const log = logger('libp2p:ping');
class DefaultPingService {
    protocol;
    components;
    started;
    timeout;
    maxInboundStreams;
    maxOutboundStreams;
    runOnTransientConnection;
    constructor(components, init) {
        this.components = components;
        this.started = false;
        this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
        this.timeout = init.timeout ?? TIMEOUT;
        this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS;
        this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS;
        this.runOnTransientConnection = init.runOnTransientConnection ?? true;
    }
    async start() {
        await this.components.registrar.handle(this.protocol, this.handleMessage, {
            maxInboundStreams: this.maxInboundStreams,
            maxOutboundStreams: this.maxOutboundStreams,
            runOnTransientConnection: this.runOnTransientConnection
        });
        this.started = true;
    }
    async stop() {
        await this.components.registrar.unhandle(this.protocol);
        this.started = false;
    }
    isStarted() {
        return this.started;
    }
    /**
     * A handler to register with Libp2p to process ping messages
     */
    handleMessage(data) {
        log('incoming ping from %p', data.connection.remotePeer);
        const { stream } = data;
        const start = Date.now();
        void pipe(stream, stream)
            .catch(err => {
            log.error('incoming ping from %p failed with error', data.connection.remotePeer, err);
        })
            .finally(() => {
            const ms = Date.now() - start;
            log('incoming ping from %p complete in %dms', data.connection.remotePeer, ms);
        });
    }
    /**
     * Ping a given peer and wait for its response, getting the operation latency.
     *
     * @param {PeerId|Multiaddr} peer
     * @returns {Promise<number>}
     */
    async ping(peer, options = {}) {
        log('pinging %p', peer);
        const start = Date.now();
        const data = randomBytes(PING_LENGTH);
        const connection = await this.components.connectionManager.openConnection(peer, options);
        let stream;
        let onAbort = () => { };
        if (options.signal == null) {
            const signal = AbortSignal.timeout(this.timeout);
            options = {
                ...options,
                signal
            };
        }
        try {
            stream = await connection.newStream(this.protocol, {
                ...options,
                runOnTransientConnection: this.runOnTransientConnection
            });
            onAbort = () => {
                stream?.abort(new CodeError('ping timeout', codes.ERR_TIMEOUT));
            };
            // make stream abortable
            options.signal?.addEventListener('abort', onAbort, { once: true });
            const result = await pipe([data], stream, async (source) => first(source));
            const ms = Date.now() - start;
            if (result == null) {
                throw new CodeError(`Did not receive a ping ack after ${ms}ms`, codes.ERR_WRONG_PING_ACK);
            }
            if (!uint8ArrayEquals(data, result.subarray())) {
                throw new CodeError(`Received wrong ping ack after ${ms}ms`, codes.ERR_WRONG_PING_ACK);
            }
            log('ping %p complete in %dms', connection.remotePeer, ms);
            return ms;
        }
        catch (err) {
            log.error('error while pinging %p', connection.remotePeer, err);
            stream?.abort(err);
            throw err;
        }
        finally {
            options.signal?.removeEventListener('abort', onAbort);
            if (stream != null) {
                await stream.close();
            }
        }
    }
}
export function pingService(init = {}) {
    return (components) => new DefaultPingService(components, init);
}
//# sourceMappingURL=index.js.map