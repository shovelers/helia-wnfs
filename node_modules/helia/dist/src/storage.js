import { start, stop } from '@libp2p/interface/startable';
import createMortice from 'mortice';
/**
 * BlockStorage is a hybrid blockstore that puts/gets blocks from a configured
 * blockstore (that may be on disk, s3, or something else). If the blocks are
 * not present Bitswap will be used to fetch them from network peers.
 */
export class BlockStorage {
    lock;
    child;
    pins;
    started;
    /**
     * Create a new BlockStorage
     */
    constructor(blockstore, pins, options = {}) {
        this.child = blockstore;
        this.pins = pins;
        this.lock = createMortice({
            singleProcess: options.holdGcLock
        });
        this.started = false;
    }
    isStarted() {
        return this.started;
    }
    async start() {
        await start(this.child);
        this.started = true;
    }
    async stop() {
        await stop(this.child);
        this.started = false;
    }
    unwrap() {
        return this.child;
    }
    /**
     * Put a block to the underlying datastore
     */
    async put(cid, block, options = {}) {
        const releaseLock = await this.lock.readLock();
        try {
            return await this.child.put(cid, block, options);
        }
        finally {
            releaseLock();
        }
    }
    /**
     * Put a multiple blocks to the underlying datastore
     */
    async *putMany(blocks, options = {}) {
        const releaseLock = await this.lock.readLock();
        try {
            yield* this.child.putMany(blocks, options);
        }
        finally {
            releaseLock();
        }
    }
    /**
     * Get a block by cid
     */
    async get(cid, options = {}) {
        const releaseLock = await this.lock.readLock();
        try {
            return await this.child.get(cid, options);
        }
        finally {
            releaseLock();
        }
    }
    /**
     * Get multiple blocks back from an (async) iterable of cids
     */
    async *getMany(cids, options = {}) {
        const releaseLock = await this.lock.readLock();
        try {
            yield* this.child.getMany(cids, options);
        }
        finally {
            releaseLock();
        }
    }
    /**
     * Delete a block from the blockstore
     */
    async delete(cid, options = {}) {
        const releaseLock = await this.lock.writeLock();
        try {
            if (await this.pins.isPinned(cid)) {
                throw new Error('CID was pinned');
            }
            await this.child.delete(cid, options);
        }
        finally {
            releaseLock();
        }
    }
    /**
     * Delete multiple blocks from the blockstore
     */
    async *deleteMany(cids, options = {}) {
        const releaseLock = await this.lock.writeLock();
        try {
            const storage = this;
            yield* this.child.deleteMany((async function* () {
                for await (const cid of cids) {
                    if (await storage.pins.isPinned(cid)) {
                        throw new Error('CID was pinned');
                    }
                    yield cid;
                }
            }()), options);
        }
        finally {
            releaseLock();
        }
    }
    async has(cid, options = {}) {
        const releaseLock = await this.lock.readLock();
        try {
            return await this.child.has(cid, options);
        }
        finally {
            releaseLock();
        }
    }
    async *getAll(options = {}) {
        const releaseLock = await this.lock.readLock();
        try {
            yield* this.child.getAll(options);
        }
        finally {
            releaseLock();
        }
    }
}
//# sourceMappingURL=storage.js.map