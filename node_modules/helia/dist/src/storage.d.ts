import { type Startable } from '@libp2p/interface/startable';
import type { Blocks, Pair, DeleteManyBlocksProgressEvents, DeleteBlockProgressEvents, GetBlockProgressEvents, GetManyBlocksProgressEvents, PutManyBlocksProgressEvents, PutBlockProgressEvents, GetAllBlocksProgressEvents, GetOfflineOptions } from '@helia/interface/blocks';
import type { Pins } from '@helia/interface/pins';
import type { AbortOptions } from '@libp2p/interface';
import type { Blockstore } from 'interface-blockstore';
import type { AwaitIterable } from 'interface-store';
import type { Mortice } from 'mortice';
import type { CID } from 'multiformats/cid';
import type { ProgressOptions } from 'progress-events';
export interface BlockStorageInit {
    holdGcLock?: boolean;
}
export interface GetOptions extends AbortOptions {
    progress?(evt: Event): void;
}
/**
 * BlockStorage is a hybrid blockstore that puts/gets blocks from a configured
 * blockstore (that may be on disk, s3, or something else). If the blocks are
 * not present Bitswap will be used to fetch them from network peers.
 */
export declare class BlockStorage implements Blocks, Startable {
    lock: Mortice;
    private readonly child;
    private readonly pins;
    private started;
    /**
     * Create a new BlockStorage
     */
    constructor(blockstore: Blockstore, pins: Pins, options?: BlockStorageInit);
    isStarted(): boolean;
    start(): Promise<void>;
    stop(): Promise<void>;
    unwrap(): Blockstore;
    /**
     * Put a block to the underlying datastore
     */
    put(cid: CID, block: Uint8Array, options?: AbortOptions & ProgressOptions<PutBlockProgressEvents>): Promise<CID>;
    /**
     * Put a multiple blocks to the underlying datastore
     */
    putMany(blocks: AwaitIterable<{
        cid: CID;
        block: Uint8Array;
    }>, options?: AbortOptions & ProgressOptions<PutManyBlocksProgressEvents>): AsyncIterable<CID>;
    /**
     * Get a block by cid
     */
    get(cid: CID, options?: GetOfflineOptions & AbortOptions & ProgressOptions<GetBlockProgressEvents>): Promise<Uint8Array>;
    /**
     * Get multiple blocks back from an (async) iterable of cids
     */
    getMany(cids: AwaitIterable<CID>, options?: GetOfflineOptions & AbortOptions & ProgressOptions<GetManyBlocksProgressEvents>): AsyncIterable<Pair>;
    /**
     * Delete a block from the blockstore
     */
    delete(cid: CID, options?: AbortOptions & ProgressOptions<DeleteBlockProgressEvents>): Promise<void>;
    /**
     * Delete multiple blocks from the blockstore
     */
    deleteMany(cids: AwaitIterable<CID>, options?: AbortOptions & ProgressOptions<DeleteManyBlocksProgressEvents>): AsyncIterable<CID>;
    has(cid: CID, options?: AbortOptions): Promise<boolean>;
    getAll(options?: AbortOptions & ProgressOptions<GetAllBlocksProgressEvents>): AsyncIterable<Pair>;
}
//# sourceMappingURL=storage.d.ts.map