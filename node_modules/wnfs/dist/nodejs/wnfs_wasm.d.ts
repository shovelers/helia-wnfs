/* tslint:disable */
/* eslint-disable */
/**
* @param {AccessKey} access_key
* @param {number} share_count
* @param {string} sharer_root_did
* @param {Uint8Array} recipient_exchange_root
* @param {PrivateForest} forest
* @param {BlockStore} store
* @returns {Promise<any>}
*/
export function share(access_key: AccessKey, share_count: number, sharer_root_did: string, recipient_exchange_root: Uint8Array, forest: PrivateForest, store: BlockStore): Promise<any>;
/**
* @param {number} share_count
* @param {string} sharer_root_did
* @param {Uint8Array} recipient_exchange_key
* @param {PrivateForest} forest
* @returns {Name}
*/
export function createShareName(share_count: number, sharer_root_did: string, recipient_exchange_key: Uint8Array, forest: PrivateForest): Name;
/**
* @param {number} share_count
* @param {number} limit
* @param {Uint8Array} recipient_exchange_key
* @param {string} sharer_root_did
* @param {PrivateForest} forest
* @param {BlockStore} store
* @returns {Promise<any>}
*/
export function findLatestShareCounter(share_count: number, limit: number, recipient_exchange_key: Uint8Array, sharer_root_did: string, forest: PrivateForest, store: BlockStore): Promise<any>;
/**
* @param {Name} share_name
* @param {PrivateKey} recipient_key
* @param {PrivateForest} forest
* @param {BlockStore} store
* @returns {Promise<any>}
*/
export function receiveShare(share_name: Name, recipient_key: PrivateKey, forest: PrivateForest, store: BlockStore): Promise<any>;
/**
* Panic hook lets us get better error messages if our Rust code ever panics.
*
* This function needs to be called at least once during initialisation.
* https://rustwasm.github.io/docs/wasm-pack/tutorials/npm-browser-packages/template-deep-dive/src-utils-rs.html#2-what-is-console_error_panic_hook
*/
export function setPanicHook(): void;

export interface BlockStore {
    putBlock(bytes: Uint8Array, code: number): Promise<Uint8Array>;
    getBlock(cid: Uint8Array): Promise<Uint8Array | undefined>;
}


/**
*/
export class AccessKey {
  free(): void;
/**
* Return the label in the forest, used for
* accessing the ciphertext that can be decrypted with
* this access key.
* @returns {Uint8Array}
*/
  getLabel(): Uint8Array;
/**
* Returns the temporal key or null, in case this
* access key only gives access to the shapshot level.
* @returns {Uint8Array | undefined}
*/
  getTemporalKey(): Uint8Array | undefined;
/**
* Returns the snapshot key.
* May derive the key on-the-fly in case this
* AccessKey also gives access to the temporal access level.
* @returns {Uint8Array}
*/
  getSnapshotKey(): Uint8Array;
/**
* Return the CID of what this access key decrypts.
* This is mainly used for disambiguation, in case the
* label the AccessKey links to has multiple conflicting writes.
* @returns {Uint8Array}
*/
  getContentCid(): Uint8Array;
/**
* Serialize this AccessKey into bytes.
* This will contain secret key material!
* Make sure to keep safe or encrypt
* (e.g. using the WebCrypto and asymmetrically encrypting these bytes).
* @returns {Uint8Array}
*/
  toBytes(): Uint8Array;
/**
* Deserialize an AccessKey previously generated from `into_bytes`.
* @param {Uint8Array} bytes
* @returns {AccessKey}
*/
  static fromBytes(bytes: Uint8Array): AccessKey;
}
/**
* A block store provided by the host (JavaScript) for custom implementation like connection to the IPFS network.
*/
export class ForeignBlockStore {
  free(): void;
}
/**
*/
export class ForeignExchangeKey {
  free(): void;
}
/**
*/
export class ForeignPrivateKey {
  free(): void;
}
/**
*/
export class ForestChange {
  free(): void;
/**
* @returns {string}
*/
  getChangeType(): string;
/**
* @returns {NameAccumulator}
*/
  getKey(): NameAccumulator;
/**
* @returns {(Uint8Array)[]}
*/
  getValue1(): (Uint8Array)[];
/**
* @returns {(Uint8Array)[]}
*/
  getValue2(): (Uint8Array)[];
}
/**
*/
export class Name {
  free(): void;
}
/**
*/
export class NameAccumulator {
  free(): void;
}
/**
* A directory in a WNFS public file system.
*/
export class PrivateDirectory {
  free(): void;
/**
* Creates a new private directory.
* @param {Name} parent_bare_name
* @param {Date} time
* @param {Rng} rng
*/
  constructor(parent_bare_name: Name, time: Date, rng: Rng);
/**
* This contstructor creates a new private directory and stores it in a provided `PrivateForest`.
* @param {Name} parent_bare_name
* @param {Date} time
* @param {PrivateForest} forest
* @param {BlockStore} store
* @param {Rng} rng
* @returns {Promise<Promise<any>>}
*/
  static newAndStore(parent_bare_name: Name, time: Date, forest: PrivateForest, store: BlockStore, rng: Rng): Promise<Promise<any>>;
/**
* Persists the current state of this directory in the BlockStore and PrivateForest.
* This will also force a history entry to be created, if there were changes.
* @param {PrivateForest} forest
* @param {BlockStore} store
* @param {Rng} rng
* @returns {Promise<any>}
*/
  store(forest: PrivateForest, store: BlockStore, rng: Rng): Promise<any>;
/**
* Follows a path and fetches the node at the end of the path.
* @param {Array<any>} path_segments
* @param {boolean} search_latest
* @param {PrivateForest} forest
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  getNode(path_segments: Array<any>, search_latest: boolean, forest: PrivateForest, store: BlockStore): Promise<any>;
/**
* Looks up a node by its path name in the current directory.
* @param {string} path_segment
* @param {boolean} search_latest
* @param {PrivateForest} forest
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  lookupNode(path_segment: string, search_latest: boolean, forest: PrivateForest, store: BlockStore): Promise<any>;
/**
* Reads specified file content from the directory.
* @param {Array<any>} path_segments
* @param {boolean} search_latest
* @param {PrivateForest} forest
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  read(path_segments: Array<any>, search_latest: boolean, forest: PrivateForest, store: BlockStore): Promise<any>;
/**
* Returns names and metadata of the direct children of a directory.
* @param {Array<any>} path_segments
* @param {boolean} search_latest
* @param {PrivateForest} forest
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  ls(path_segments: Array<any>, search_latest: boolean, forest: PrivateForest, store: BlockStore): Promise<any>;
/**
* Removes a file or directory from the directory.
* @param {Array<any>} path_segments
* @param {boolean} search_latest
* @param {PrivateForest} forest
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  rm(path_segments: Array<any>, search_latest: boolean, forest: PrivateForest, store: BlockStore): Promise<any>;
/**
* Writes a file to the directory.
* @param {Array<any>} path_segments
* @param {boolean} search_latest
* @param {Uint8Array} content
* @param {Date} time
* @param {PrivateForest} forest
* @param {BlockStore} store
* @param {Rng} rng
* @returns {Promise<any>}
*/
  write(path_segments: Array<any>, search_latest: boolean, content: Uint8Array, time: Date, forest: PrivateForest, store: BlockStore, rng: Rng): Promise<any>;
/**
* Moves a specified path to a new location.
* @param {Array<any>} path_segments_from
* @param {Array<any>} path_segments_to
* @param {boolean} search_latest
* @param {Date} time
* @param {PrivateForest} forest
* @param {BlockStore} store
* @param {Rng} rng
* @returns {Promise<any>}
*/
  basicMv(path_segments_from: Array<any>, path_segments_to: Array<any>, search_latest: boolean, time: Date, forest: PrivateForest, store: BlockStore, rng: Rng): Promise<any>;
/**
* Copies a specified path to a new location.
* @param {Array<any>} path_segments_from
* @param {Array<any>} path_segments_to
* @param {boolean} search_latest
* @param {Date} time
* @param {PrivateForest} forest
* @param {BlockStore} store
* @param {Rng} rng
* @returns {Promise<any>}
*/
  cp(path_segments_from: Array<any>, path_segments_to: Array<any>, search_latest: boolean, time: Date, forest: PrivateForest, store: BlockStore, rng: Rng): Promise<any>;
/**
* Creates a new directory at the specified path.
*
* This method acts like `mkdir -p` in Unix because it creates intermediate directories if they do not exist.
* @param {Array<any>} path_segments
* @param {boolean} search_latest
* @param {Date} time
* @param {PrivateForest} forest
* @param {BlockStore} store
* @param {Rng} rng
* @returns {Promise<any>}
*/
  mkdir(path_segments: Array<any>, search_latest: boolean, time: Date, forest: PrivateForest, store: BlockStore, rng: Rng): Promise<any>;
/**
* Gets the metadata of the directory
* @returns {any}
*/
  metadata(): any;
/**
* Converts directory to a node.
* @returns {PrivateNode}
*/
  asNode(): PrivateNode;
/**
* Gets a unique id for node.
* @returns {string}
*/
  getId(): string;
}
/**
* A file in a WNFS public file system.
*/
export class PrivateFile {
  free(): void;
/**
* Creates an empty private file.
* @param {Name} parent_bare_name
* @param {Date} time
* @param {Rng} rng
*/
  constructor(parent_bare_name: Name, time: Date, rng: Rng);
/**
* Creates a file with provided content.
* @param {Name} parent_bare_name
* @param {Date} time
* @param {Uint8Array} content
* @param {PrivateForest} forest
* @param {BlockStore} store
* @param {Rng} rng
* @returns {Promise<any>}
*/
  static withContent(parent_bare_name: Name, time: Date, content: Uint8Array, forest: PrivateForest, store: BlockStore, rng: Rng): Promise<any>;
/**
* Persists the current state of this file in the BlockStore and PrivateForest.
* This will also force a history entry to be created, if there were changes.
* @param {PrivateForest} forest
* @param {BlockStore} store
* @param {Rng} rng
* @returns {Promise<any>}
*/
  store(forest: PrivateForest, store: BlockStore, rng: Rng): Promise<any>;
/**
* Gets the entire content of a file.
* @param {PrivateForest} forest
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  getContent(forest: PrivateForest, store: BlockStore): Promise<any>;
/**
* Gets the metadata of this file.
* @returns {any}
*/
  metadata(): any;
/**
* Gets a unique id for node.
* @returns {string}
*/
  getId(): string;
/**
* Converts this file to a node.
* @returns {PrivateNode}
*/
  asNode(): PrivateNode;
}
/**
* A reference to a private forest. Used for the private file system.
*/
export class PrivateForest {
  free(): void;
/**
* Creates a new private forest.
* @param {Rng} rng
* @param {Uint8Array | undefined} [rsa_modulus_big_endian]
*/
  constructor(rng: Rng, rsa_modulus_big_endian?: Uint8Array);
/**
* Loads an existing private forest from a given CID
* You need to have previously `.store()`ed it to get its CID.
* @param {Uint8Array} cid
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  static load(cid: Uint8Array, store: BlockStore): Promise<any>;
/**
* Stores this private forest in provided block store.
* Returns the CID from which it can be `.load()`ed again.
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  store(store: BlockStore): Promise<any>;
/**
* @param {PrivateForest} other
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  merge(other: PrivateForest, store: BlockStore): Promise<any>;
/**
* @param {PrivateForest} other
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  diff(other: PrivateForest, store: BlockStore): Promise<any>;
/**
* @returns {Name}
*/
  emptyName(): Name;
}
/**
* Wraps `wnfs::PrivateNode`.
*/
export class PrivateNode {
  free(): void;
/**
* Persists the current state of this node in the BlockStore and PrivateForest.
* This will also force a history entry to be created, if there were changes.
* @param {PrivateForest} forest
* @param {BlockStore} store
* @param {Rng} rng
* @returns {Promise<any>}
*/
  store(forest: PrivateForest, store: BlockStore, rng: Rng): Promise<any>;
/**
* Loads a node from the PrivateForest using the AccessKey.
* @param {AccessKey} access_key
* @param {PrivateForest} forest
* @param {BlockStore} store
* @param {Name | undefined} [parent_name]
* @returns {Promise<any>}
*/
  static load(access_key: AccessKey, forest: PrivateForest, store: BlockStore, parent_name?: Name): Promise<any>;
/**
* @param {PrivateForest} forest
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  searchLatest(forest: PrivateForest, store: BlockStore): Promise<any>;
/**
* @returns {PrivateDirectory}
*/
  asDir(): PrivateDirectory;
/**
* @returns {PrivateFile}
*/
  asFile(): PrivateFile;
/**
* @returns {boolean}
*/
  isDir(): boolean;
/**
* @returns {boolean}
*/
  isFile(): boolean;
/**
* @returns {string}
*/
  getId(): string;
}
/**
* A directory in a WNFS public file system.
*/
export class PublicDirectory {
  free(): void;
/**
* Creates a new directory using the given metadata.
* @param {Date} time
*/
  constructor(time: Date);
/**
* Follows a path and fetches the node at the end of the path.
* @param {Array<any>} path_segments
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  getNode(path_segments: Array<any>, store: BlockStore): Promise<any>;
/**
* Looks up a node by its path name in the current directory.
* @param {string} path_segment
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  lookupNode(path_segment: string, store: BlockStore): Promise<any>;
/**
* Stores directory in provided block store.
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  store(store: BlockStore): Promise<any>;
/**
* Loads a directory given its CID from the block store.
* @param {Uint8Array} cid
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  static load(cid: Uint8Array, store: BlockStore): Promise<any>;
/**
* Reads specified file content from the directory.
* @param {Array<any>} path_segments
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  read(path_segments: Array<any>, store: BlockStore): Promise<any>;
/**
* Returns names and metadata of the direct children of a directory.
* @param {Array<any>} path_segments
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  ls(path_segments: Array<any>, store: BlockStore): Promise<any>;
/**
* Removes a file or directory from the directory.
* @param {Array<any>} path_segments
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  rm(path_segments: Array<any>, store: BlockStore): Promise<any>;
/**
* Writes a file to the directory.
* @param {Array<any>} path_segments
* @param {Uint8Array} content
* @param {Date} time
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  write(path_segments: Array<any>, content: Uint8Array, time: Date, store: BlockStore): Promise<any>;
/**
* Moves a specified path to a new location.
* @param {Array<any>} path_segments_from
* @param {Array<any>} path_segments_to
* @param {Date} time
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  basicMv(path_segments_from: Array<any>, path_segments_to: Array<any>, time: Date, store: BlockStore): Promise<any>;
/**
* Copies a specific node to another location.
* @param {Array<any>} path_segments_from
* @param {Array<any>} path_segments_to
* @param {Date} time
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  cp(path_segments_from: Array<any>, path_segments_to: Array<any>, time: Date, store: BlockStore): Promise<any>;
/**
* Creates a new directory at the specified path.
*
* This method acts like `mkdir -p` in Unix because it creates intermediate directories if they do not exist.
* @param {Array<any>} path_segments
* @param {Date} time
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  mkdir(path_segments: Array<any>, time: Date, store: BlockStore): Promise<any>;
/**
* Gets the previous CID(s) of the directory.
* This will usually be an array of a single CID, but may be
* - an empty array, if this is the first revision of a directory
* - an array with multiple elements if this is the merge node of
*   multiple concurrent changes to the directory.
* @returns {(Uint8Array)[]}
*/
  previousCids(): (Uint8Array)[];
/**
* Gets the metadata of the directory
* @returns {any}
*/
  metadata(): any;
/**
* Converts directory to a node.
* @returns {PublicNode}
*/
  asNode(): PublicNode;
/**
* Gets a unique id for node.
* @returns {string}
*/
  getId(): string;
}
/**
* A file in a WNFS public file system.
*/
export class PublicFile {
  free(): void;
/**
* Creates a new file in a WNFS public file system.
* @param {Date} time
*/
  constructor(time: Date);
/**
* Gets a unique id for node.
* @returns {string}
*/
  getId(): string;
/**
* Stores a file in provided block store.
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  store(store: BlockStore): Promise<any>;
/**
* Loads a file given its CID from the block store.
* @param {Uint8Array} cid
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  static load(cid: Uint8Array, store: BlockStore): Promise<any>;
/**
* Gets the previous CID(s) of the file.
* This will usually be an array of a single CID, but may be
* - an empty array, if this is the first revision of a file
* - an array with multiple elements if this is the merge node of
*   multiple concurrent changes to the file.
* @returns {(Uint8Array)[]}
*/
  previousCids(): (Uint8Array)[];
/**
* Gets the metadata of this file.
* @returns {any}
*/
  metadata(): any;
/**
* Gets the content of the file at given offset & with an optional byte limit.
* @param {number} byte_offset
* @param {number | undefined} limit
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  readAt(byte_offset: number, limit: number | undefined, store: BlockStore): Promise<any>;
/**
* Sets the content of a file to a byte array.
* @param {Date} time
* @param {Uint8Array} content
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  setContent(time: Date, content: Uint8Array, store: BlockStore): Promise<any>;
/**
* Converts this directory to a node.
* @returns {PublicNode}
*/
  asNode(): PublicNode;
}
/**
* Wraps a wnfs PublicNode.
*/
export class PublicNode {
  free(): void;
/**
* @returns {PublicDirectory}
*/
  asDir(): PublicDirectory;
/**
* @returns {PublicFile}
*/
  asFile(): PublicFile;
/**
* @returns {boolean}
*/
  isDir(): boolean;
/**
* @returns {boolean}
*/
  isFile(): boolean;
/**
* @returns {string}
*/
  getId(): string;
}
