/* tslint:disable */
/* eslint-disable */
/**
* @param {AccessKey} access_key
* @param {number} share_count
* @param {string} sharer_root_did
* @param {Uint8Array} recipient_exchange_root
* @param {PrivateForest} forest
* @param {BlockStore} store
* @returns {Promise<any>}
*/
export function share(access_key: AccessKey, share_count: number, sharer_root_did: string, recipient_exchange_root: Uint8Array, forest: PrivateForest, store: BlockStore): Promise<any>;
/**
* @param {number} share_count
* @param {string} sharer_root_did
* @param {Uint8Array} recipient_exchange_key
* @param {PrivateForest} forest
* @returns {Name}
*/
export function createShareName(share_count: number, sharer_root_did: string, recipient_exchange_key: Uint8Array, forest: PrivateForest): Name;
/**
* @param {number} share_count
* @param {number} limit
* @param {Uint8Array} recipient_exchange_key
* @param {string} sharer_root_did
* @param {PrivateForest} forest
* @param {BlockStore} store
* @returns {Promise<any>}
*/
export function findLatestShareCounter(share_count: number, limit: number, recipient_exchange_key: Uint8Array, sharer_root_did: string, forest: PrivateForest, store: BlockStore): Promise<any>;
/**
* @param {Name} share_name
* @param {PrivateKey} recipient_key
* @param {PrivateForest} forest
* @param {BlockStore} store
* @returns {Promise<any>}
*/
export function receiveShare(share_name: Name, recipient_key: PrivateKey, forest: PrivateForest, store: BlockStore): Promise<any>;
/**
* Panic hook lets us get better error messages if our Rust code ever panics.
*
* This function needs to be called at least once during initialisation.
* https://rustwasm.github.io/docs/wasm-pack/tutorials/npm-browser-packages/template-deep-dive/src-utils-rs.html#2-what-is-console_error_panic_hook
*/
export function setPanicHook(): void;

export interface BlockStore {
    putBlock(bytes: Uint8Array, code: number): Promise<Uint8Array>;
    getBlock(cid: Uint8Array): Promise<Uint8Array | undefined>;
}


/**
*/
export class AccessKey {
  free(): void;
/**
* Return the label in the forest, used for
* accessing the ciphertext that can be decrypted with
* this access key.
* @returns {Uint8Array}
*/
  getLabel(): Uint8Array;
/**
* Returns the temporal key or null, in case this
* access key only gives access to the shapshot level.
* @returns {Uint8Array | undefined}
*/
  getTemporalKey(): Uint8Array | undefined;
/**
* Returns the snapshot key.
* May derive the key on-the-fly in case this
* AccessKey also gives access to the temporal access level.
* @returns {Uint8Array}
*/
  getSnapshotKey(): Uint8Array;
/**
* Return the CID of what this access key decrypts.
* This is mainly used for disambiguation, in case the
* label the AccessKey links to has multiple conflicting writes.
* @returns {Uint8Array}
*/
  getContentCid(): Uint8Array;
/**
* Serialize this AccessKey into bytes.
* This will contain secret key material!
* Make sure to keep safe or encrypt
* (e.g. using the WebCrypto and asymmetrically encrypting these bytes).
* @returns {Uint8Array}
*/
  toBytes(): Uint8Array;
/**
* Deserialize an AccessKey previously generated from `into_bytes`.
* @param {Uint8Array} bytes
* @returns {AccessKey}
*/
  static fromBytes(bytes: Uint8Array): AccessKey;
}
/**
* A block store provided by the host (JavaScript) for custom implementation like connection to the IPFS network.
*/
export class ForeignBlockStore {
  free(): void;
}
/**
*/
export class ForeignExchangeKey {
  free(): void;
}
/**
*/
export class ForeignPrivateKey {
  free(): void;
}
/**
*/
export class ForestChange {
  free(): void;
/**
* @returns {string}
*/
  getChangeType(): string;
/**
* @returns {NameAccumulator}
*/
  getKey(): NameAccumulator;
/**
* @returns {(Uint8Array)[]}
*/
  getValue1(): (Uint8Array)[];
/**
* @returns {(Uint8Array)[]}
*/
  getValue2(): (Uint8Array)[];
}
/**
*/
export class Name {
  free(): void;
}
/**
*/
export class NameAccumulator {
  free(): void;
}
/**
* A directory in a WNFS public file system.
*/
export class PrivateDirectory {
  free(): void;
/**
* Creates a new private directory.
* @param {Name} parent_bare_name
* @param {Date} time
* @param {Rng} rng
*/
  constructor(parent_bare_name: Name, time: Date, rng: Rng);
/**
* This contstructor creates a new private directory and stores it in a provided `PrivateForest`.
* @param {Name} parent_bare_name
* @param {Date} time
* @param {PrivateForest} forest
* @param {BlockStore} store
* @param {Rng} rng
* @returns {Promise<Promise<any>>}
*/
  static newAndStore(parent_bare_name: Name, time: Date, forest: PrivateForest, store: BlockStore, rng: Rng): Promise<Promise<any>>;
/**
* Persists the current state of this directory in the BlockStore and PrivateForest.
* This will also force a history entry to be created, if there were changes.
* @param {PrivateForest} forest
* @param {BlockStore} store
* @param {Rng} rng
* @returns {Promise<any>}
*/
  store(forest: PrivateForest, store: BlockStore, rng: Rng): Promise<any>;
/**
* Follows a path and fetches the node at the end of the path.
* @param {Array<any>} path_segments
* @param {boolean} search_latest
* @param {PrivateForest} forest
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  getNode(path_segments: Array<any>, search_latest: boolean, forest: PrivateForest, store: BlockStore): Promise<any>;
/**
* Looks up a node by its path name in the current directory.
* @param {string} path_segment
* @param {boolean} search_latest
* @param {PrivateForest} forest
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  lookupNode(path_segment: string, search_latest: boolean, forest: PrivateForest, store: BlockStore): Promise<any>;
/**
* Reads specified file content from the directory.
* @param {Array<any>} path_segments
* @param {boolean} search_latest
* @param {PrivateForest} forest
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  read(path_segments: Array<any>, search_latest: boolean, forest: PrivateForest, store: BlockStore): Promise<any>;
/**
* Returns names and metadata of the direct children of a directory.
* @param {Array<any>} path_segments
* @param {boolean} search_latest
* @param {PrivateForest} forest
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  ls(path_segments: Array<any>, search_latest: boolean, forest: PrivateForest, store: BlockStore): Promise<any>;
/**
* Removes a file or directory from the directory.
* @param {Array<any>} path_segments
* @param {boolean} search_latest
* @param {PrivateForest} forest
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  rm(path_segments: Array<any>, search_latest: boolean, forest: PrivateForest, store: BlockStore): Promise<any>;
/**
* Writes a file to the directory.
* @param {Array<any>} path_segments
* @param {boolean} search_latest
* @param {Uint8Array} content
* @param {Date} time
* @param {PrivateForest} forest
* @param {BlockStore} store
* @param {Rng} rng
* @returns {Promise<any>}
*/
  write(path_segments: Array<any>, search_latest: boolean, content: Uint8Array, time: Date, forest: PrivateForest, store: BlockStore, rng: Rng): Promise<any>;
/**
* Moves a specified path to a new location.
* @param {Array<any>} path_segments_from
* @param {Array<any>} path_segments_to
* @param {boolean} search_latest
* @param {Date} time
* @param {PrivateForest} forest
* @param {BlockStore} store
* @param {Rng} rng
* @returns {Promise<any>}
*/
  basicMv(path_segments_from: Array<any>, path_segments_to: Array<any>, search_latest: boolean, time: Date, forest: PrivateForest, store: BlockStore, rng: Rng): Promise<any>;
/**
* Copies a specified path to a new location.
* @param {Array<any>} path_segments_from
* @param {Array<any>} path_segments_to
* @param {boolean} search_latest
* @param {Date} time
* @param {PrivateForest} forest
* @param {BlockStore} store
* @param {Rng} rng
* @returns {Promise<any>}
*/
  cp(path_segments_from: Array<any>, path_segments_to: Array<any>, search_latest: boolean, time: Date, forest: PrivateForest, store: BlockStore, rng: Rng): Promise<any>;
/**
* Creates a new directory at the specified path.
*
* This method acts like `mkdir -p` in Unix because it creates intermediate directories if they do not exist.
* @param {Array<any>} path_segments
* @param {boolean} search_latest
* @param {Date} time
* @param {PrivateForest} forest
* @param {BlockStore} store
* @param {Rng} rng
* @returns {Promise<any>}
*/
  mkdir(path_segments: Array<any>, search_latest: boolean, time: Date, forest: PrivateForest, store: BlockStore, rng: Rng): Promise<any>;
/**
* Gets the metadata of the directory
* @returns {any}
*/
  metadata(): any;
/**
* Converts directory to a node.
* @returns {PrivateNode}
*/
  asNode(): PrivateNode;
/**
* Gets a unique id for node.
* @returns {string}
*/
  getId(): string;
}
/**
* A file in a WNFS public file system.
*/
export class PrivateFile {
  free(): void;
/**
* Creates an empty private file.
* @param {Name} parent_bare_name
* @param {Date} time
* @param {Rng} rng
*/
  constructor(parent_bare_name: Name, time: Date, rng: Rng);
/**
* Creates a file with provided content.
* @param {Name} parent_bare_name
* @param {Date} time
* @param {Uint8Array} content
* @param {PrivateForest} forest
* @param {BlockStore} store
* @param {Rng} rng
* @returns {Promise<any>}
*/
  static withContent(parent_bare_name: Name, time: Date, content: Uint8Array, forest: PrivateForest, store: BlockStore, rng: Rng): Promise<any>;
/**
* Persists the current state of this file in the BlockStore and PrivateForest.
* This will also force a history entry to be created, if there were changes.
* @param {PrivateForest} forest
* @param {BlockStore} store
* @param {Rng} rng
* @returns {Promise<any>}
*/
  store(forest: PrivateForest, store: BlockStore, rng: Rng): Promise<any>;
/**
* Gets the entire content of a file.
* @param {PrivateForest} forest
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  getContent(forest: PrivateForest, store: BlockStore): Promise<any>;
/**
* Gets the metadata of this file.
* @returns {any}
*/
  metadata(): any;
/**
* Gets a unique id for node.
* @returns {string}
*/
  getId(): string;
/**
* Converts this file to a node.
* @returns {PrivateNode}
*/
  asNode(): PrivateNode;
}
/**
* A reference to a private forest. Used for the private file system.
*/
export class PrivateForest {
  free(): void;
/**
* Creates a new private forest.
* @param {Rng} rng
* @param {Uint8Array | undefined} rsa_modulus_big_endian
*/
  constructor(rng: Rng, rsa_modulus_big_endian?: Uint8Array);
/**
* Loads an existing private forest from a given CID
* You need to have previously `.store()`ed it to get its CID.
* @param {Uint8Array} cid
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  static load(cid: Uint8Array, store: BlockStore): Promise<any>;
/**
* Stores this private forest in provided block store.
* Returns the CID from which it can be `.load()`ed again.
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  store(store: BlockStore): Promise<any>;
/**
* @param {PrivateForest} other
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  merge(other: PrivateForest, store: BlockStore): Promise<any>;
/**
* @param {PrivateForest} other
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  diff(other: PrivateForest, store: BlockStore): Promise<any>;
/**
* @returns {Name}
*/
  emptyName(): Name;
}
/**
* Wraps `wnfs::PrivateNode`.
*/
export class PrivateNode {
  free(): void;
/**
* Persists the current state of this node in the BlockStore and PrivateForest.
* This will also force a history entry to be created, if there were changes.
* @param {PrivateForest} forest
* @param {BlockStore} store
* @param {Rng} rng
* @returns {Promise<any>}
*/
  store(forest: PrivateForest, store: BlockStore, rng: Rng): Promise<any>;
/**
* Loads a node from the PrivateForest using the AccessKey.
* @param {AccessKey} access_key
* @param {PrivateForest} forest
* @param {BlockStore} store
* @param {Name | undefined} parent_name
* @returns {Promise<any>}
*/
  static load(access_key: AccessKey, forest: PrivateForest, store: BlockStore, parent_name?: Name): Promise<any>;
/**
* @param {PrivateForest} forest
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  searchLatest(forest: PrivateForest, store: BlockStore): Promise<any>;
/**
* @returns {PrivateDirectory}
*/
  asDir(): PrivateDirectory;
/**
* @returns {PrivateFile}
*/
  asFile(): PrivateFile;
/**
* @returns {boolean}
*/
  isDir(): boolean;
/**
* @returns {boolean}
*/
  isFile(): boolean;
/**
* @returns {string}
*/
  getId(): string;
}
/**
* A directory in a WNFS public file system.
*/
export class PublicDirectory {
  free(): void;
/**
* Creates a new directory using the given metadata.
* @param {Date} time
*/
  constructor(time: Date);
/**
* Follows a path and fetches the node at the end of the path.
* @param {Array<any>} path_segments
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  getNode(path_segments: Array<any>, store: BlockStore): Promise<any>;
/**
* Looks up a node by its path name in the current directory.
* @param {string} path_segment
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  lookupNode(path_segment: string, store: BlockStore): Promise<any>;
/**
* Stores directory in provided block store.
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  store(store: BlockStore): Promise<any>;
/**
* Loads a directory given its CID from the block store.
* @param {Uint8Array} cid
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  static load(cid: Uint8Array, store: BlockStore): Promise<any>;
/**
* Reads specified file content from the directory.
* @param {Array<any>} path_segments
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  read(path_segments: Array<any>, store: BlockStore): Promise<any>;
/**
* Returns names and metadata of the direct children of a directory.
* @param {Array<any>} path_segments
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  ls(path_segments: Array<any>, store: BlockStore): Promise<any>;
/**
* Removes a file or directory from the directory.
* @param {Array<any>} path_segments
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  rm(path_segments: Array<any>, store: BlockStore): Promise<any>;
/**
* Writes a file to the directory.
* @param {Array<any>} path_segments
* @param {Uint8Array} content_cid
* @param {Date} time
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  write(path_segments: Array<any>, content_cid: Uint8Array, time: Date, store: BlockStore): Promise<any>;
/**
* Moves a specified path to a new location.
* @param {Array<any>} path_segments_from
* @param {Array<any>} path_segments_to
* @param {Date} time
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  basicMv(path_segments_from: Array<any>, path_segments_to: Array<any>, time: Date, store: BlockStore): Promise<any>;
/**
* Copies a specific node to another location.
* @param {Array<any>} path_segments_from
* @param {Array<any>} path_segments_to
* @param {Date} time
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  cp(path_segments_from: Array<any>, path_segments_to: Array<any>, time: Date, store: BlockStore): Promise<any>;
/**
* Creates a new directory at the specified path.
*
* This method acts like `mkdir -p` in Unix because it creates intermediate directories if they do not exist.
* @param {Array<any>} path_segments
* @param {Date} time
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  mkdir(path_segments: Array<any>, time: Date, store: BlockStore): Promise<any>;
/**
* Gets the previous CID(s) of the directory.
* This will usually be an array of a single CID, but may be
* - an empty array, if this is the first revision of a directory
* - an array with multiple elements if this is the merge node of
*   multiple concurrent changes to the directory.
* @returns {(Uint8Array)[]}
*/
  previousCids(): (Uint8Array)[];
/**
* Gets the metadata of the directory
* @returns {any}
*/
  metadata(): any;
/**
* Converts directory to a node.
* @returns {PublicNode}
*/
  asNode(): PublicNode;
/**
* Gets a unique id for node.
* @returns {string}
*/
  getId(): string;
}
/**
* A file in a WNFS public file system.
*/
export class PublicFile {
  free(): void;
/**
* Creates a new file in a WNFS public file system.
* @param {Date} time
* @param {Uint8Array} cid
*/
  constructor(time: Date, cid: Uint8Array);
/**
* Gets a unique id for node.
* @returns {string}
*/
  getId(): string;
/**
* Stores a file in provided block store.
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  store(store: BlockStore): Promise<any>;
/**
* Loads a file given its CID from the block store.
* @param {Uint8Array} cid
* @param {BlockStore} store
* @returns {Promise<any>}
*/
  static load(cid: Uint8Array, store: BlockStore): Promise<any>;
/**
* Gets the previous CID(s) of the file.
* This will usually be an array of a single CID, but may be
* - an empty array, if this is the first revision of a file
* - an array with multiple elements if this is the merge node of
*   multiple concurrent changes to the file.
* @returns {(Uint8Array)[]}
*/
  previousCids(): (Uint8Array)[];
/**
* Gets the metadata of this file.
* @returns {any}
*/
  metadata(): any;
/**
* Gets the content cid of the file.
* @returns {Uint8Array}
*/
  contentCid(): Uint8Array;
/**
* Converts this directory to a node.
* @returns {PublicNode}
*/
  asNode(): PublicNode;
}
/**
* Wraps a wnfs PublicNode.
*/
export class PublicNode {
  free(): void;
/**
* @returns {PublicDirectory}
*/
  asDir(): PublicDirectory;
/**
* @returns {PublicFile}
*/
  asFile(): PublicFile;
/**
* @returns {boolean}
*/
  isDir(): boolean;
/**
* @returns {boolean}
*/
  isFile(): boolean;
/**
* @returns {string}
*/
  getId(): string;
}

export type InitInput = RequestInfo | URL | Response | BufferSource | WebAssembly.Module;

export interface InitOutput {
  readonly memory: WebAssembly.Memory;
  readonly __wbg_foreignblockstore_free: (a: number) => void;
  readonly __wbg_accesskey_free: (a: number) => void;
  readonly accesskey_getLabel: (a: number, b: number) => void;
  readonly accesskey_getTemporalKey: (a: number, b: number) => void;
  readonly accesskey_getSnapshotKey: (a: number, b: number) => void;
  readonly accesskey_getContentCid: (a: number, b: number) => void;
  readonly accesskey_toBytes: (a: number, b: number) => void;
  readonly accesskey_fromBytes: (a: number, b: number) => number;
  readonly __wbg_privatedirectory_free: (a: number) => void;
  readonly privatedirectory_new: (a: number, b: number, c: number, d: number) => void;
  readonly privatedirectory_newAndStore: (a: number, b: number, c: number, d: number, e: number) => number;
  readonly privatedirectory_store: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly privatedirectory_getNode: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly privatedirectory_lookupNode: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly privatedirectory_read: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly privatedirectory_ls: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly privatedirectory_rm: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly privatedirectory_write: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number) => void;
  readonly privatedirectory_basicMv: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number) => void;
  readonly privatedirectory_cp: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number) => void;
  readonly privatedirectory_mkdir: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number) => void;
  readonly privatedirectory_metadata: (a: number, b: number) => void;
  readonly privatedirectory_asNode: (a: number) => number;
  readonly privatedirectory_getId: (a: number, b: number) => void;
  readonly __wbg_privatefile_free: (a: number) => void;
  readonly privatefile_new: (a: number, b: number, c: number, d: number) => void;
  readonly privatefile_withContent: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number) => void;
  readonly privatefile_store: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly privatefile_getContent: (a: number, b: number, c: number, d: number) => void;
  readonly privatefile_metadata: (a: number, b: number) => void;
  readonly privatefile_getId: (a: number, b: number) => void;
  readonly privatefile_asNode: (a: number) => number;
  readonly __wbg_privateforest_free: (a: number) => void;
  readonly privateforest_new: (a: number, b: number, c: number, d: number) => void;
  readonly privateforest_load: (a: number, b: number, c: number, d: number) => void;
  readonly privateforest_store: (a: number, b: number, c: number) => void;
  readonly privateforest_merge: (a: number, b: number, c: number, d: number) => void;
  readonly privateforest_diff: (a: number, b: number, c: number, d: number) => void;
  readonly privateforest_emptyName: (a: number) => number;
  readonly __wbg_name_free: (a: number) => void;
  readonly __wbg_nameaccumulator_free: (a: number) => void;
  readonly __wbg_privatenode_free: (a: number) => void;
  readonly __wbg_forestchange_free: (a: number) => void;
  readonly privatenode_store: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly privatenode_load: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly privatenode_searchLatest: (a: number, b: number, c: number, d: number) => void;
  readonly privatenode_asDir: (a: number, b: number) => void;
  readonly privatenode_asFile: (a: number, b: number) => void;
  readonly privatenode_isDir: (a: number) => number;
  readonly privatenode_isFile: (a: number) => number;
  readonly privatenode_getId: (a: number, b: number) => void;
  readonly forestchange_getChangeType: (a: number, b: number) => void;
  readonly forestchange_getKey: (a: number) => number;
  readonly forestchange_getValue1: (a: number, b: number) => void;
  readonly forestchange_getValue2: (a: number, b: number) => void;
  readonly share: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number) => void;
  readonly createShareName: (a: number, b: number, c: number, d: number, e: number, f: number) => number;
  readonly findLatestShareCounter: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number) => void;
  readonly receiveShare: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly __wbg_publicdirectory_free: (a: number) => void;
  readonly publicdirectory_new: (a: number) => number;
  readonly publicdirectory_getNode: (a: number, b: number, c: number, d: number) => void;
  readonly publicdirectory_lookupNode: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly publicdirectory_store: (a: number, b: number, c: number) => void;
  readonly publicdirectory_load: (a: number, b: number, c: number, d: number) => void;
  readonly publicdirectory_read: (a: number, b: number, c: number, d: number) => void;
  readonly publicdirectory_ls: (a: number, b: number, c: number, d: number) => void;
  readonly publicdirectory_rm: (a: number, b: number, c: number, d: number) => void;
  readonly publicdirectory_write: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly publicdirectory_basicMv: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly publicdirectory_cp: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly publicdirectory_mkdir: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly publicdirectory_previousCids: (a: number, b: number) => void;
  readonly publicdirectory_metadata: (a: number, b: number) => void;
  readonly publicdirectory_asNode: (a: number) => number;
  readonly publicdirectory_getId: (a: number, b: number) => void;
  readonly __wbg_publicfile_free: (a: number) => void;
  readonly publicfile_new: (a: number, b: number, c: number, d: number) => void;
  readonly publicfile_getId: (a: number, b: number) => void;
  readonly publicfile_store: (a: number, b: number, c: number) => void;
  readonly publicfile_load: (a: number, b: number, c: number, d: number) => void;
  readonly publicfile_previousCids: (a: number, b: number) => void;
  readonly publicfile_metadata: (a: number, b: number) => void;
  readonly publicfile_contentCid: (a: number, b: number) => void;
  readonly publicfile_asNode: (a: number) => number;
  readonly __wbg_publicnode_free: (a: number) => void;
  readonly publicnode_asDir: (a: number, b: number) => void;
  readonly publicnode_asFile: (a: number, b: number) => void;
  readonly publicnode_isDir: (a: number) => number;
  readonly publicnode_isFile: (a: number) => number;
  readonly publicnode_getId: (a: number, b: number) => void;
  readonly setPanicHook: () => void;
  readonly __wbg_foreignexchangekey_free: (a: number) => void;
  readonly __wbg_foreignprivatekey_free: (a: number) => void;
  readonly __wbindgen_export_0: (a: number, b: number) => number;
  readonly __wbindgen_export_1: (a: number, b: number, c: number, d: number) => number;
  readonly __wbindgen_export_2: WebAssembly.Table;
  readonly __wbindgen_export_3: (a: number, b: number, c: number) => void;
  readonly __wbindgen_export_4: (a: number, b: number, c: number) => void;
  readonly __wbindgen_add_to_stack_pointer: (a: number) => number;
  readonly __wbindgen_export_5: (a: number) => void;
  readonly __wbindgen_export_6: (a: number, b: number, c: number, d: number) => void;
}

export type SyncInitInput = BufferSource | WebAssembly.Module;
/**
* Instantiates the given `module`, which can either be bytes or
* a precompiled `WebAssembly.Module`.
*
* @param {SyncInitInput} module
*
* @returns {InitOutput}
*/
export function initSync(module: SyncInitInput): InitOutput;

/**
* If `module_or_path` is {RequestInfo} or {URL}, makes a request and
* for everything else, calls `WebAssembly.instantiate` directly.
*
* @param {InitInput | Promise<InitInput>} module_or_path
*
* @returns {Promise<InitOutput>}
*/
export default function __wbg_init (module_or_path?: InitInput | Promise<InitInput>): Promise<InitOutput>;
