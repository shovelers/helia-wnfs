import {} from '@libp2p/interface/content-routing';
import { CodeError } from '@libp2p/interface/errors';
import {} from '@libp2p/interface/peer-routing';
import { peerIdFromBytes } from '@libp2p/peer-id';
import { marshal, unmarshal } from 'ipns';
import first from 'it-first';
import map from 'it-map';
import { equals as uint8ArrayEquals } from 'uint8arrays/equals';
import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';
const IPNS_PREFIX = uint8ArrayFromString('/ipns/');
function isIPNSKey(key) {
    return uint8ArrayEquals(key.subarray(0, IPNS_PREFIX.byteLength), IPNS_PREFIX);
}
const peerIdFromRoutingKey = (key) => {
    return peerIdFromBytes(key.slice(IPNS_PREFIX.length));
};
/**
 * Wrapper class to convert [http-routing-v1 content events](https://specs.ipfs.tech/routing/http-routing-v1/#response-body) into returned values
 */
export class DelegatedRoutingV1HttpApiClientContentRouting {
    client;
    constructor(client) {
        this.client = client;
    }
    async *findProviders(cid, options = {}) {
        yield* map(this.client.getProviders(cid, options), (record) => {
            return {
                id: record.ID,
                multiaddrs: record.Addrs ?? [],
                protocols: []
            };
        });
    }
    async provide() {
        // noop
    }
    async put(key, value, options) {
        if (!isIPNSKey(key)) {
            return;
        }
        const peerId = peerIdFromRoutingKey(key);
        const record = unmarshal(value);
        await this.client.putIPNS(peerId, record, options);
    }
    async get(key, options) {
        if (!isIPNSKey(key)) {
            throw new CodeError('Not found', 'ERR_NOT_FOUND');
        }
        const peerId = peerIdFromRoutingKey(key);
        try {
            const record = await this.client.getIPNS(peerId, options);
            return marshal(record);
        }
        catch (err) {
            // ERR_BAD_RESPONSE is thrown when the response had no body, which means
            // the record couldn't be found
            if (err.code === 'ERR_BAD_RESPONSE') {
                throw new CodeError('Not found', 'ERR_NOT_FOUND');
            }
            throw err;
        }
    }
}
/**
 * Wrapper class to convert [http-routing-v1](https://specs.ipfs.tech/routing/http-routing-v1/#response-body-0) events into expected libp2p values
 */
export class DelegatedRoutingV1HttpApiClientPeerRouting {
    client;
    constructor(client) {
        this.client = client;
    }
    async findPeer(peerId, options = {}) {
        const peer = await first(this.client.getPeers(peerId, options));
        if (peer != null) {
            return {
                id: peer.ID,
                multiaddrs: peer.Addrs,
                protocols: []
            };
        }
        throw new CodeError('Not found', 'ERR_NOT_FOUND');
    }
    async *getClosestPeers(key, options = {}) {
        // noop
    }
}
//# sourceMappingURL=routings.js.map