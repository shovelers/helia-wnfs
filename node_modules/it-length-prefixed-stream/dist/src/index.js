/**
 * @packageDocumentation
 *
 * This module makes it easy to send and receive length-prefixed byte arrays over streams.
 *
 * @example
 *
 * ```typescript
 * import { lpStream } from 'it-length-prefixed-stream'
 *
 * const stream = lpStream(duplex)
 *
 * // read the next length-prefixed chunk
 * const bytes = await stream.read()
 *
 * // write a length-prefixed chunk
 * await stream.write(Uint8Array.from([0, 1, 2, 3, 4]))
 *
 * // write several chunks, all individually length-prefixed
 * await stream.writeV([
 *   Uint8Array.from([0, 1, 2, 3, 4]),
 *   Uint8Array.from([5, 6, 7, 8, 9])
 * ])
 * ```
 */
import { byteStream } from 'it-byte-stream';
import * as lp from 'it-length-prefixed';
import * as varint from 'uint8-varint';
import { Uint8ArrayList } from 'uint8arraylist';
class CodeError extends Error {
    code;
    constructor(message, code) {
        super(message);
        this.code = code;
    }
}
const defaultLengthDecoder = (buf) => {
    return varint.decode(buf);
};
defaultLengthDecoder.bytes = 0;
export function lpStream(duplex, opts = {}) {
    const bytes = byteStream(duplex, opts);
    if (opts.maxDataLength != null && opts.maxLengthLength == null) {
        // if max data length is set but max length length is not, calculate the
        // max length length needed to encode max data length
        opts.maxLengthLength = varint.encodingLength(opts.maxDataLength);
    }
    const W = {
        read: async (options) => {
            let dataLength = -1;
            const lengthBuffer = new Uint8ArrayList();
            const decodeLength = opts?.lengthDecoder ?? defaultLengthDecoder;
            while (true) {
                // read one byte at a time until we can decode a varint
                lengthBuffer.append(await bytes.read(1, options));
                try {
                    dataLength = decodeLength(lengthBuffer);
                }
                catch (err) {
                    if (err instanceof RangeError) {
                        continue;
                    }
                    throw err;
                }
                if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {
                    throw new CodeError('message length length too long', 'ERR_MSG_LENGTH_TOO_LONG');
                }
                if (dataLength > -1) {
                    break;
                }
            }
            if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {
                throw new CodeError('message length too long', 'ERR_MSG_DATA_TOO_LONG');
            }
            return bytes.read(dataLength, options);
        },
        write: async (data, options) => {
            // encode, write
            await bytes.write(lp.encode.single(data, opts), options);
        },
        writeV: async (data, options) => {
            const list = new Uint8ArrayList(...data.map(buf => lp.encode.single(buf, opts)));
            // encode, write
            await bytes.write(list, options);
        },
        unwrap: () => {
            return bytes.unwrap();
        }
    };
    return W;
}
//# sourceMappingURL=index.js.map