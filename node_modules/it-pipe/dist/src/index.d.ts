import type { Duplex, Transform, Sink } from 'it-stream-types';
interface SourceFn<A = any> {
    (): A;
}
type PipeSource<A = any> = Iterable<A> | AsyncIterable<A> | SourceFn<A> | Duplex<A, any, any>;
type PipeTransform<A = any, B = any> = Transform<A, B> | Duplex<B, A>;
type PipeSink<A = any, B = any> = Sink<A, B> | Duplex<any, A, B>;
type PipeOutput<A> = A extends Sink<any> ? ReturnType<A> : A extends Duplex<any, any, any> ? ReturnType<A['sink']> : never;
type SingleItemPipeOutput<A> = A extends Iterable<any> ? A : A extends AsyncIterable<any> ? A : A extends SourceFn ? ReturnType<A> : A extends Duplex<any, any, any> ? A['source'] : PipeOutput<A>;
type PipeFnInput<A> = A extends Iterable<any> ? A : A extends AsyncIterable<any> ? A : A extends SourceFn ? ReturnType<A> : A extends Transform<any, any> ? ReturnType<A> : A extends Duplex<any, any, any> ? A['source'] : never;
export declare function pipe<A extends PipeSource>(source: A): SingleItemPipeOutput<A>;
export declare function pipe<A extends PipeSource, B extends PipeSink<PipeFnInput<A>>>(source: A, sink: B): PipeOutput<B>;
export declare function pipe<A extends PipeSource, B extends PipeTransform<PipeFnInput<A>>, C extends PipeSink<PipeFnInput<B>>>(source: A, transform1: B, sink: C): PipeOutput<C>;
export declare function pipe<A extends PipeSource, B extends PipeTransform<PipeFnInput<A>>, C extends PipeTransform<PipeFnInput<B>>, D extends PipeSink<PipeFnInput<C>>>(source: A, transform1: B, transform2: C, sink: D): PipeOutput<D>;
export declare function pipe<A extends PipeSource, B extends PipeTransform<PipeFnInput<A>>, C extends PipeTransform<PipeFnInput<B>>, D extends PipeTransform<PipeFnInput<C>>, E extends PipeSink<PipeFnInput<D>>>(source: A, transform1: B, transform2: C, transform3: D, sink: E): PipeOutput<E>;
export declare function pipe<A extends PipeSource, B extends PipeTransform<PipeFnInput<A>>, C extends PipeTransform<PipeFnInput<B>>, D extends PipeTransform<PipeFnInput<C>>, E extends PipeTransform<PipeFnInput<D>>, F extends PipeSink<PipeFnInput<E>>>(source: A, transform1: B, transform2: C, transform3: D, transform4: E, sink: F): PipeOutput<F>;
export declare function pipe<A extends PipeSource, B extends PipeTransform<PipeFnInput<A>>, C extends PipeTransform<PipeFnInput<B>>, D extends PipeTransform<PipeFnInput<C>>, E extends PipeTransform<PipeFnInput<D>>, F extends PipeTransform<PipeFnInput<E>>, G extends PipeSink<PipeFnInput<F>>>(source: A, transform1: B, transform2: C, transform3: D, transform4: E, transform5: F, sink: G): PipeOutput<G>;
export declare function pipe<A extends PipeSource, B extends PipeTransform<PipeFnInput<A>>, C extends PipeTransform<PipeFnInput<B>>, D extends PipeTransform<PipeFnInput<C>>, E extends PipeTransform<PipeFnInput<D>>, F extends PipeTransform<PipeFnInput<E>>, G extends PipeTransform<PipeFnInput<F>>, H extends PipeSink<PipeFnInput<G>>>(source: A, transform1: B, transform2: C, transform3: D, transform4: E, transform5: F, transform6: G, sink: H): PipeOutput<H>;
export declare function pipe<A extends PipeSource, B extends PipeTransform<PipeFnInput<A>>, C extends PipeTransform<PipeFnInput<B>>, D extends PipeTransform<PipeFnInput<C>>, E extends PipeTransform<PipeFnInput<D>>, F extends PipeTransform<PipeFnInput<E>>, G extends PipeTransform<PipeFnInput<F>>, H extends PipeTransform<PipeFnInput<G>>, I extends PipeSink<PipeFnInput<H>>>(source: A, transform1: B, transform2: C, transform3: D, transform4: E, transform5: F, transform6: G, transform7: H, sink: I): PipeOutput<I>;
export declare function pipe<A extends PipeSource, B extends PipeTransform<PipeFnInput<A>>, C extends PipeTransform<PipeFnInput<B>>, D extends PipeTransform<PipeFnInput<C>>, E extends PipeTransform<PipeFnInput<D>>, F extends PipeTransform<PipeFnInput<E>>, G extends PipeTransform<PipeFnInput<F>>, H extends PipeTransform<PipeFnInput<G>>, I extends PipeTransform<PipeFnInput<H>>, J extends PipeSink<PipeFnInput<I>>>(source: A, transform1: B, transform2: C, transform3: D, transform4: E, transform5: F, transform6: G, transform7: H, transform8: I, sink: J): PipeOutput<J>;
export declare function pipe<A extends PipeSource, B extends PipeTransform<PipeFnInput<A>>, C extends PipeTransform<PipeFnInput<B>>, D extends PipeTransform<PipeFnInput<C>>, E extends PipeTransform<PipeFnInput<D>>, F extends PipeTransform<PipeFnInput<E>>, G extends PipeTransform<PipeFnInput<F>>, H extends PipeTransform<PipeFnInput<G>>, I extends PipeTransform<PipeFnInput<H>>, J extends PipeTransform<PipeFnInput<I>>, K extends PipeSink<PipeFnInput<J>>>(source: A, transform1: B, transform2: C, transform3: D, transform4: E, transform5: F, transform6: G, transform7: H, transform8: I, transform9: J, sink: K): PipeOutput<K>;
export declare function pipe<A extends PipeSource, B extends PipeTransform<PipeFnInput<A>>, C extends PipeTransform<PipeFnInput<B>>, D extends PipeTransform<PipeFnInput<C>>, E extends PipeTransform<PipeFnInput<D>>, F extends PipeTransform<PipeFnInput<E>>, G extends PipeTransform<PipeFnInput<F>>, H extends PipeTransform<PipeFnInput<G>>, I extends PipeTransform<PipeFnInput<H>>, J extends PipeTransform<PipeFnInput<I>>, K extends PipeTransform<PipeFnInput<J>>, L extends PipeSink<PipeFnInput<K>>>(source: A, transform1: B, transform2: C, transform3: D, transform4: E, transform5: F, transform6: G, transform7: H, transform8: I, transform9: J, transform10: K, sink: L): PipeOutput<L>;
export declare const rawPipe: (...fns: any) => any;
export {};
//# sourceMappingURL=index.d.ts.map