(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.ChainsafeLibp2PYamux = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var ChainsafeLibp2PYamux=(()=>{var Y=Object.defineProperty;var Lt=Object.getOwnPropertyDescriptor;var Dt=Object.getOwnPropertyNames;var Ct=Object.prototype.hasOwnProperty;var Tt=(s,t)=>{for(var e in t)Y(s,e,{get:t[e],enumerable:!0})},Nt=(s,t,e,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of Dt(t))!Ct.call(s,n)&&n!==e&&Y(s,n,{get:()=>t[n],enumerable:!(r=Lt(t,n))||r.enumerable});return s};var Ot=s=>Nt(Y({},"__esModule",{value:!0}),s);var Ht={};Tt(Ht,{GoAwayCode:()=>m,yamux:()=>Yt});var $t=Symbol.for("@libp2p/connection");var Qt=Symbol.for("@libp2p/content-routing");var te=Symbol.for("@libp2p/peer-discovery");var re=Symbol.for("@libp2p/peer-id");var ne=Symbol.for("@libp2p/peer-routing");var ot;(function(s){s.Accept="accept",s.Ignore="ignore",s.Reject="reject"})(ot||(ot={}));var le=Symbol.for("@libp2p/transport");var at;(function(s){s[s.FATAL_ALL=0]="FATAL_ALL",s[s.NO_FATAL=1]="NO_FATAL"})(at||(at={}));var a=class extends Error{code;props;constructor(t,e,r){super(t),this.code=e,this.name=r?.name??"CodeError",this.props=r??{}}};var H=class extends Event{detail;constructor(t,e){super(t,e),this.detail=e?.detail}},me=globalThis.CustomEvent??H,q=(s,...t)=>{try{[...t]}catch{}};function U(s){if(s!=null){if(typeof s[Symbol.iterator]=="function")return s[Symbol.iterator]();if(typeof s[Symbol.asyncIterator]=="function")return s[Symbol.asyncIterator]();if(typeof s.next=="function")return s}throw new Error("argument is not an iterator or iterable")}function x(){let s={};return s.promise=new Promise((t,e)=>{s.resolve=t,s.reject=e}),s}var W=class{buffer;mask;top;btm;next;constructor(t){if(!(t>0)||t-1&t)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(t),this.mask=t-1,this.top=0,this.btm=0,this.next=null}push(t){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=t,this.top=this.top+1&this.mask,!0)}shift(){let t=this.buffer[this.btm];if(t!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,t}isEmpty(){return this.buffer[this.btm]===void 0}},v=class{size;hwm;head;tail;constructor(t={}){this.hwm=t.splitLimit??16,this.head=new W(this.hwm),this.tail=this.head,this.size=0}calculateSize(t){return t?.byteLength!=null?t.byteLength:1}push(t){if(t?.value!=null&&(this.size+=this.calculateSize(t.value)),!this.head.push(t)){let e=this.head;this.head=e.next=new W(2*this.head.buffer.length),this.head.push(t)}}shift(){let t=this.tail.shift();if(t===void 0&&this.tail.next!=null){let e=this.tail.next;this.tail.next=null,this.tail=e,t=this.tail.shift()}return t?.value!=null&&(this.size-=this.calculateSize(t.value)),t}isEmpty(){return this.head.isEmpty()}};var K=class extends Error{type;code;constructor(t,e){super(t??"The operation was aborted"),this.type="aborted",this.code=e??"ABORT_ERR"}};function k(s={}){return Ut(e=>{let r=e.shift();if(r==null)return{done:!0};if(r.error!=null)throw r.error;return{done:r.done===!0,value:r.value}},s)}function Ut(s,t){t=t??{};let e=t.onEnd,r=new v,n,i,o,l=x(),h=async()=>{try{return r.isEmpty()?o?{done:!0}:await new Promise((u,_)=>{i=O=>{i=null,r.push(O);try{u(s(r))}catch(A){_(A)}return n}}):s(r)}finally{r.isEmpty()&&queueMicrotask(()=>{l.resolve(),l=x()})}},w=u=>i!=null?i(u):(r.push(u),n),g=u=>(r=new v,i!=null?i({error:u}):(r.push({error:u}),n)),d=u=>{if(o)return n;if(t?.objectMode!==!0&&u?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return w({done:!1,value:u})},b=u=>o?n:(o=!0,u!=null?g(u):w({done:!0})),N=()=>(r=new v,b(),{done:!0}),At=u=>(b(u),{done:!0});if(n={[Symbol.asyncIterator](){return this},next:h,return:N,throw:At,push:d,end:b,get readableLength(){return r.size},onEmpty:async u=>{let _=u?.signal;if(_?.throwIfAborted(),r.isEmpty())return;let O,A;_!=null&&(O=new Promise((qt,vt)=>{A=()=>{vt(new K)},_.addEventListener("abort",A)}));try{await Promise.race([l.promise,O])}finally{A!=null&&_!=null&&_?.removeEventListener("abort",A)}}},e==null)return n;let I=n;return n={[Symbol.asyncIterator](){return this},next(){return I.next()},throw(u){return I.throw(u),e!=null&&(e(u),e=void 0),{done:!0}},return(){return I.return(),e!=null&&(e(),e=void 0),{done:!0}},push:d,end(u){return I.end(u),e!=null&&(e(u),e=void 0),n},get readableLength(){return I.readableLength},onEmpty:u=>I.onEmpty(u)},n}function L(s){return globalThis.Buffer!=null?new Uint8Array(s.buffer,s.byteOffset,s.byteLength):s}function y(s=0){return globalThis.Buffer?.alloc!=null?L(globalThis.Buffer.alloc(s)):new Uint8Array(s)}function C(s=0){return globalThis.Buffer?.allocUnsafe!=null?L(globalThis.Buffer.allocUnsafe(s)):new Uint8Array(s)}function $(s,t){if(globalThis.Buffer!=null)return L(globalThis.Buffer.concat(s,t));t==null&&(t=s.reduce((n,i)=>n+i.length,0));let e=C(t),r=0;for(let n of s)e.set(n,r),r+=n.length;return L(e)}function lt(s,t){if(s===t)return!0;if(s.byteLength!==t.byteLength)return!1;for(let e=0;e<s.byteLength;e++)if(s[e]!==t[e])return!1;return!0}var ht=Symbol.for("@achingbrain/uint8arraylist");function ut(s,t){if(t==null||t<0)throw new RangeError("index is out of bounds");let e=0;for(let r of s){let n=e+r.byteLength;if(t<n)return{buf:r,index:t-e};e=n}throw new RangeError("index is out of bounds")}function M(s){return!!s?.[ht]}var E=class s{bufs;length;[ht]=!0;constructor(...t){this.bufs=[],this.length=0,t.length>0&&this.appendAll(t)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...t){this.appendAll(t)}appendAll(t){let e=0;for(let r of t)if(r instanceof Uint8Array)e+=r.byteLength,this.bufs.push(r);else if(M(r))e+=r.byteLength,this.bufs.push(...r.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}prepend(...t){this.prependAll(t)}prependAll(t){let e=0;for(let r of t.reverse())if(r instanceof Uint8Array)e+=r.byteLength,this.bufs.unshift(r);else if(M(r))e+=r.byteLength,this.bufs.unshift(...r.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}get(t){let e=ut(this.bufs,t);return e.buf[e.index]}set(t,e){let r=ut(this.bufs,t);r.buf[r.index]=e}write(t,e=0){if(t instanceof Uint8Array)for(let r=0;r<t.length;r++)this.set(e+r,t[r]);else if(M(t))for(let r=0;r<t.length;r++)this.set(e+r,t.get(r));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(t){if(t=Math.trunc(t),!(Number.isNaN(t)||t<=0)){if(t===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(t>=this.bufs[0].byteLength)t-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(t),this.length-=t;break}}}slice(t,e){let{bufs:r,length:n}=this._subList(t,e);return $(r,n)}subarray(t,e){let{bufs:r,length:n}=this._subList(t,e);return r.length===1?r[0]:$(r,n)}sublist(t,e){let{bufs:r,length:n}=this._subList(t,e),i=new s;return i.length=n,i.bufs=[...r],i}_subList(t,e){if(t=t??0,e=e??this.length,t<0&&(t=this.length+t),e<0&&(e=this.length+e),t<0||e>this.length)throw new RangeError("index is out of bounds");if(t===e)return{bufs:[],length:0};if(t===0&&e===this.length)return{bufs:this.bufs,length:this.length};let r=[],n=0;for(let i=0;i<this.bufs.length;i++){let o=this.bufs[i],l=n,h=l+o.byteLength;if(n=h,t>=h)continue;let w=t>=l&&t<h,g=e>l&&e<=h;if(w&&g){if(t===l&&e===h){r.push(o);break}let d=t-l;r.push(o.subarray(d,d+(e-t)));break}if(w){if(t===0){r.push(o);continue}r.push(o.subarray(t-l));continue}if(g){if(e===h){r.push(o);break}r.push(o.subarray(0,e-l));break}r.push(o)}return{bufs:r,length:e-t}}indexOf(t,e=0){if(!M(t)&&!(t instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');let r=t instanceof Uint8Array?t:t.subarray();if(e=Number(e??0),isNaN(e)&&(e=0),e<0&&(e=this.length+e),e<0&&(e=0),t.length===0)return e>this.length?this.length:e;let n=r.byteLength;if(n===0)throw new TypeError("search must be at least 1 byte long");let i=256,o=new Int32Array(i);for(let d=0;d<i;d++)o[d]=-1;for(let d=0;d<n;d++)o[r[d]]=d;let l=o,h=this.byteLength-r.byteLength,w=r.byteLength-1,g;for(let d=e;d<=h;d+=g){g=0;for(let b=w;b>=0;b--){let N=this.get(d+b);if(r[b]!==N){g=Math.max(1,b-l[N]);break}}if(g===0)return d}return-1}getInt8(t){let e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getInt8(0)}setInt8(t,e){let r=C(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt8(0,e),this.write(r,t)}getInt16(t,e){let r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt16(0,e)}setInt16(t,e,r){let n=y(2);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt16(0,e,r),this.write(n,t)}getInt32(t,e){let r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt32(0,e)}setInt32(t,e,r){let n=y(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt32(0,e,r),this.write(n,t)}getBigInt64(t,e){let r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigInt64(0,e)}setBigInt64(t,e,r){let n=y(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setBigInt64(0,e,r),this.write(n,t)}getUint8(t){let e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getUint8(0)}setUint8(t,e){let r=C(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint8(0,e),this.write(r,t)}getUint16(t,e){let r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,e)}setUint16(t,e,r){let n=y(2);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint16(0,e,r),this.write(n,t)}getUint32(t,e){let r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint32(0,e)}setUint32(t,e,r){let n=y(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint32(0,e,r),this.write(n,t)}getBigUint64(t,e){let r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,e)}setBigUint64(t,e,r){let n=y(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setBigUint64(0,e,r),this.write(n,t)}getFloat32(t,e){let r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat32(0,e)}setFloat32(t,e,r){let n=y(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setFloat32(0,e,r),this.write(n,t)}getFloat64(t,e){let r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat64(0,e)}setFloat64(t,e,r){let n=y(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setFloat64(0,e,r),this.write(n,t)}equals(t){if(t==null||!(t instanceof s)||t.bufs.length!==this.bufs.length)return!1;for(let e=0;e<this.bufs.length;e++)if(!lt(this.bufs[e],t.bufs[e]))return!1;return!0}static fromUint8Arrays(t,e){let r=new s;return r.bufs=t,e==null&&(e=t.reduce((n,i)=>n+i.byteLength,0)),r.length=e,r}};var D="ERR_INVALID_FRAME",j="ERR_UNREQUESTED_PING",Q="ERR_NOT_MATCHING_PING",J="ERR_STREAM_ALREADY_EXISTS",Z="ERR_DECODE_INVALID_VERSION",tt="ERR_BOTH_CLIENTS",et="ERR_RECV_WINDOW_EXCEEDED",ct=new Set([D,j,Q,J,Z,tt,et]),S="ERR_INVALID_CONFIG",P="ERR_MUXER_LOCAL_CLOSED",rt="ERR_MUXER_REMOTE_CLOSED";var ft="ERR_STREAM_ABORT",dt="ERROR_MAX_OUTBOUND_STREAMS_EXCEEDED",mt="ERR_DECODE_IN_PROGRESS",T=256*1024,pt=16*1024*1024;var wt={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,initialStreamWindowSize:T,maxStreamWindowSize:pt,maxMessageSize:64*1024};function gt(s){if(s.keepAliveInterval<=0)throw new a("keep-alive interval must be positive",S);if(s.maxInboundStreams<0)throw new a("max inbound streams must be larger or equal 0",S);if(s.maxOutboundStreams<0)throw new a("max outbound streams must be larger or equal 0",S);if(s.initialStreamWindowSize<T)throw new a("InitialStreamWindowSize must be larger or equal 256 kB",S);if(s.maxStreamWindowSize<s.initialStreamWindowSize)throw new a("MaxStreamWindowSize must be larger than the InitialStreamWindowSize",S);if(s.maxStreamWindowSize>2**32-1)throw new a("MaxStreamWindowSize must be less than equal MAX_UINT32",S);if(s.maxMessageSize<1024)throw new a("MaxMessageSize must be greater than a kilobyte",S)}var f;(function(s){s[s.Data=0]="Data",s[s.WindowUpdate=1]="WindowUpdate",s[s.Ping=2]="Ping",s[s.GoAway=3]="GoAway"})(f||(f={}));var c;(function(s){s[s.SYN=1]="SYN",s[s.ACK=2]="ACK",s[s.FIN=4]="FIN",s[s.RST=8]="RST"})(c||(c={}));var or=Object.values(c).filter(s=>typeof s!="string"),bt=0,m;(function(s){s[s.NormalTermination=0]="NormalTermination",s[s.ProtocolError=1]="ProtocolError",s[s.InternalError=2]="InternalError"})(m||(m={}));var R=12;var yt=2**24;function Wt(s){if(s[0]!==bt)throw new a("Invalid frame version",Z);return{type:s[1],flag:(s[2]<<8)+s[3],streamID:s[4]*yt+(s[5]<<16)+(s[6]<<8)+s[7],length:s[8]*yt+(s[9]<<16)+(s[10]<<8)+s[11]}}var F=class{source;buffer;frameInProgress;constructor(t){this.source=kt(t),this.buffer=new E,this.frameInProgress=!1}async*emitFrames(){for await(let t of this.source)for(this.buffer.append(t);;){let e=this.readHeader();if(e===void 0)break;let{type:r,length:n}=e;r===f.Data?(this.frameInProgress=!0,yield{header:e,readData:this.readBytes.bind(this,n)}):yield{header:e}}}readHeader(){if(this.frameInProgress)throw new a("decoding frame already in progress",mt);if(this.buffer.length<R)return;let t=Wt(this.buffer.subarray(0,R));return this.buffer.consume(R),t}async readBytes(t){if(this.buffer.length<t){for await(let r of this.source)if(this.buffer.append(r),this.buffer.length>=t)break}let e=this.buffer.sublist(0,t);return this.buffer.consume(t),this.frameInProgress=!1,e}};function kt(s){if(s[Symbol.iterator]!==void 0){let t=s[Symbol.iterator]();return t.return=void 0,{[Symbol.iterator](){return t}}}else if(s[Symbol.asyncIterator]!==void 0){let t=s[Symbol.asyncIterator]();return t.return=void 0,{[Symbol.asyncIterator](){return t}}}else throw new Error("a source must be either an iterable or an async iterable")}function st(s){let t=new Uint8Array(R);return t[1]=s.type,t[2]=s.flag>>>8,t[3]=s.flag,t[4]=s.streamID>>>24,t[5]=s.streamID>>>16,t[6]=s.streamID>>>8,t[7]=s.streamID,t[8]=s.length>>>24,t[9]=s.length>>>16,t[10]=s.length>>>8,t[11]=s.length,t}var V=class extends Error{type;code;constructor(t,e){super(t??"The operation was aborted"),this.type="aborted",this.name="AbortError",this.code=e??"ABORT_ERR"}};async function G(s,t,e){if(t==null)return s;if(t.aborted)return Promise.reject(new V(e?.errorMessage,e?.errorCode));let r,n=new V(e?.errorMessage,e?.errorCode);try{return await Promise.race([s,new Promise((i,o)=>{r=()=>{o(n)},t.addEventListener("abort",r)})])}finally{r!=null&&t.removeEventListener("abort",r)}}function Et(s){return s==null?!1:typeof s.then=="function"&&typeof s.catch=="function"&&typeof s.finally=="function"}function St(s,t){let e=U(s).return?.();Et(e)&&e.catch(r=>{t.error("could not cause iterator to return",r)})}var Mt="ERR_STREAM_RESET",Pt="ERR_SINK_INVALID_STATE",Ft=5e3;function nt(s){return s==null?!1:typeof s.then=="function"&&typeof s.catch=="function"&&typeof s.finally=="function"}var B=class{id;direction;timeline;protocol;metadata;source;status;readStatus;writeStatus;log;sinkController;sinkEnd;closed;endErr;streamSource;onEnd;onCloseRead;onCloseWrite;onReset;onAbort;sendCloseWriteTimeout;constructor(t){this.sinkController=new AbortController,this.sinkEnd=x(),this.closed=x(),this.log=t.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=t.id,this.metadata=t.metadata??{},this.direction=t.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=t.sendCloseWriteTimeout??Ft,this.onEnd=t.onEnd,this.onCloseRead=t?.onCloseRead,this.onCloseWrite=t?.onCloseWrite,this.onReset=t?.onReset,this.onAbort=t?.onAbort,this.source=this.streamSource=k({onEnd:e=>{e!=null?this.log.trace("source ended with error",e):this.log.trace("source ended"),this.onSourceEnd(e)}}),this.sink=this.sink.bind(this)}async sink(t){if(this.writeStatus!=="ready")throw new a(`writable end state is "${this.writeStatus}" not "ready"`,Pt);try{this.writeStatus="writing";let e={signal:this.sinkController.signal};if(this.direction==="outbound"){let n=this.sendNewStream(e);nt(n)&&await n}let r=()=>{St(t,this.log)};try{this.sinkController.signal.addEventListener("abort",r),this.log.trace("sink reading from source");for await(let n of t){n=n instanceof Uint8Array?new E(n):n;let i=this.sendData(n,e);nt(i)&&await i}}finally{this.sinkController.signal.removeEventListener("abort",r)}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),this.writeStatus==="writing"&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(e){throw this.log.trace("sink ended with error, calling abort with error",e),this.abort(e),e}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(t){this.timeline.closeRead==null&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",t!=null&&this.endErr==null&&(this.endErr=t),this.onCloseRead?.(),this.timeline.closeWrite!=null?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(t){this.timeline.closeWrite==null&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",t!=null&&this.endErr==null&&(this.endErr=t),this.onCloseWrite?.(),this.timeline.closeRead!=null?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("sink ended, waiting for source to end"))}async close(t){this.log.trace("closing gracefully"),this.status="closing",await Promise.all([this.closeRead(t),this.closeWrite(t)]),await G(this.closed.promise,t?.signal),this.status="closed",this.log.trace("closed gracefully")}async closeRead(t={}){if(this.readStatus==="closing"||this.readStatus==="closed")return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);let e=this.readStatus;this.readStatus="closing",this.status!=="reset"&&this.status!=="aborted"&&this.timeline.closeRead==null&&(this.log.trace("send close read to remote"),await this.sendCloseRead(t)),e==="ready"&&(this.log.trace("ending internal source queue with %d queued bytes",this.streamSource.readableLength),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(t={}){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),this.writeStatus==="ready"&&(this.log.trace("sink was never sunk, sink an empty array"),await G(this.sink([]),t.signal)),this.writeStatus==="writing"&&await new Promise((e,r)=>{queueMicrotask(()=>{this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),G(this.sinkEnd.promise,t.signal).then(e,r)})}),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(t){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;this.log("abort with error",t),this.log("try to send reset to remote");let e=this.sendReset();nt(e)&&e.catch(r=>{this.log.error("error sending reset message",r)}),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(t),this.onAbort?.(t)}reset(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;let t=new a("stream reset",Mt);this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(t),this.onReset?.()}_closeSinkAndSource(t){this._closeSink(t),this._closeSource(t)}_closeSink(t){this.writeStatus==="writing"&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(t)}_closeSource(t){this.readStatus!=="closing"&&this.readStatus!=="closed"&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(t))}remoteCloseWrite(){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("received remote close write but local source is already closed");return}this.log.trace("remote close write"),this._closeSource()}remoteCloseRead(){if(this.writeStatus==="closing"||this.writeStatus==="closed"){this.log("received remote close read but local sink is already closed");return}this.log.trace("remote close read"),this._closeSink()}destroy(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset"){this.log("received destroy but we are already closed");return}this.log.trace("stream destroyed"),this._closeSinkAndSource()}sourcePush(t){this.streamSource.push(t)}sourceReadableLength(){return this.streamSource.readableLength}};function Vt(s){let[t,e]=s[Symbol.asyncIterator]!=null?[s[Symbol.asyncIterator](),Symbol.asyncIterator]:[s[Symbol.iterator](),Symbol.iterator],r=[];return{peek:()=>t.next(),push:n=>{r.push(n)},next:()=>r.length>0?{done:!1,value:r.shift()}:t.next(),[e](){return this}}}var Rt=Vt;function Gt(s){return s[Symbol.asyncIterator]!=null}function _t(s){return s?.then!=null}function Bt(s,t){if(Gt(s))return async function*(){for await(let l of s){let h=t(l);_t(h)&&await h,yield l}}();let e=Rt(s),{value:r,done:n}=e.next();if(n===!0)return function*(){}();if(typeof t(r)?.then=="function")return async function*(){yield r;for await(let l of e){let h=t(l);_t(h)&&await h,yield l}}();let o=t;return function*(){yield r;for(let l of e)o(l),yield l}()}var xt=Bt;var p;(function(s){s[s.Init=0]="Init",s[s.SYNSent=1]="SYNSent",s[s.SYNReceived=2]="SYNReceived",s[s.Established=3]="Established",s[s.Finished=4]="Finished"})(p||(p={}));var X=class extends B{name;state;config;_id;sendWindowCapacity;sendWindowCapacityUpdate;recvWindow;recvWindowCapacity;epochStart;getRTT;sendFrame;constructor(t){super({...t,onEnd:e=>{this.state=p.Finished,t.onEnd?.(e)}}),this.config=t.config,this._id=parseInt(t.id,10),this.name=t.name,this.state=t.state,this.sendWindowCapacity=T,this.recvWindow=this.config.initialStreamWindowSize,this.recvWindowCapacity=this.recvWindow,this.epochStart=Date.now(),this.getRTT=t.getRTT,this.sendFrame=t.sendFrame,this.source=xt(this.source,()=>{this.sendWindowUpdate()})}async sendNewStream(){}async sendData(t,e={}){for(t=t.sublist();t.byteLength!==0;){if(this.sendWindowCapacity===0&&await this.waitForSendWindowCapacity(e),this.status!=="open")return;let r=Math.min(this.sendWindowCapacity,this.config.maxMessageSize-R,t.length),n=this.getSendFlags();this.sendFrame({type:f.Data,flag:n,streamID:this._id,length:r},t.sublist(0,r)),this.sendWindowCapacity-=r,t.consume(r)}}async sendReset(){this.sendFrame({type:f.WindowUpdate,flag:c.RST,streamID:this._id,length:0})}async sendCloseWrite(){let t=this.getSendFlags()|c.FIN;this.sendFrame({type:f.WindowUpdate,flag:t,streamID:this._id,length:0})}async sendCloseRead(){}async waitForSendWindowCapacity(t={}){if(this.sendWindowCapacity>0)return;let e,r,n=()=>{this.status==="open"?r(new a("stream aborted",ft)):e()};t.signal?.addEventListener("abort",n);try{await new Promise((i,o)=>{this.sendWindowCapacityUpdate=()=>{i()},r=o,e=i})}finally{t.signal?.removeEventListener("abort",n)}}handleWindowUpdate(t){this.log?.trace("stream received window update id=%s",this._id),this.processFlags(t.flag);let e=this.sendWindowCapacity;this.sendWindowCapacity+=t.length,e===0&&t.length>0&&this.sendWindowCapacityUpdate?.()}async handleData(t,e){if(this.log?.trace("stream received data id=%s",this._id),this.processFlags(t.flag),this.recvWindowCapacity<t.length)throw new a("receive window exceeded",et,{available:this.recvWindowCapacity,recv:t.length});let r=await e();this.recvWindowCapacity-=t.length,this.sourcePush(r)}processFlags(t){(t&c.ACK)===c.ACK&&this.state===p.SYNSent&&(this.state=p.Established),(t&c.FIN)===c.FIN&&this.remoteCloseWrite(),(t&c.RST)===c.RST&&this.reset()}getSendFlags(){switch(this.state){case p.Init:return this.state=p.SYNSent,c.SYN;case p.SYNReceived:return this.state=p.Established,c.ACK;default:return 0}}sendWindowUpdate(){let t=this.getSendFlags(),e=Date.now(),r=this.getRTT();if(t===0&&r>-1&&e-this.epochStart<r*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.config.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&t===0)return;let n=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=e,this.sendFrame({type:f.WindowUpdate,flag:t,streamID:this._id,length:n})}};var It="/yamux/1.0.0",Xt=500,z=class{protocol=It;_components;_init;constructor(t,e={}){this._components=t,this._init=e}createStreamMuxer(t){return new it(this._components,{...this._init,...t})}},it=class{protocol=It;source;sink;config;log;logger;closeController;nextStreamID;_streams;nextPingID;activePing;rtt;client;localGoAway;remoteGoAway;numInboundStreams;numOutboundStreams;onIncomingStream;onStreamEnd;constructor(t,e){this.client=e.direction==="outbound",this.config={...wt,...e},this.logger=t.logger,this.log=this.logger.forComponent("libp2p:yamux"),gt(this.config),this.closeController=new AbortController,q(1/0,this.closeController.signal),this.onIncomingStream=e.onIncomingStream,this.onStreamEnd=e.onStreamEnd,this._streams=new Map,this.source=k({onEnd:()=>{this.log?.trace("muxer source ended"),this._streams.forEach(r=>{r.destroy()})}}),this.sink=async r=>{let n=()=>{let l=U(r);if(l.return!=null){let h=l.return();zt(h)&&h.catch(w=>{this.log?.("could not cause sink source to return",w)})}},i,o;try{let l=new F(r);try{this.closeController.signal.addEventListener("abort",n);for await(let h of l.emitFrames())await this.handleFrame(h.header,h.readData)}finally{this.closeController.signal.removeEventListener("abort",n)}i=m.NormalTermination}catch(l){let h=l.code;ct.has(h)?(this.log?.error("protocol error in sink",l),i=m.ProtocolError):(this.log?.error("internal error in sink",l),i=m.InternalError),o=l}this.log?.trace("muxer sink ended"),o!=null?this.abort(o,i):await this.close({reason:i})},this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log?.trace("muxer created"),this.config.enableKeepAlive&&this.keepAliveLoop().catch(r=>this.log?.error("keepalive error: %s",r)),this.ping().catch(r=>this.log?.error("ping error: %s",r))}get streams(){return Array.from(this._streams.values())}newStream(t){if(this.remoteGoAway!==void 0)throw new a("muxer closed remotely",rt);if(this.localGoAway!==void 0)throw new a("muxer closed locally",P);let e=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.config.maxOutboundStreams)throw new a("max outbound streams exceeded",dt);this.log?.trace("new outgoing stream id=%s",e);let r=this._newStream(e,t,p.Init,"outbound");return this._streams.set(e,r),this.numOutboundStreams++,r.sendWindowUpdate(),r}async ping(){if(this.remoteGoAway!==void 0)throw new a("muxer closed remotely",rt);if(this.localGoAway!==void 0)throw new a("muxer closed locally",P);if(this.activePing===void 0){let t=()=>{};this.activePing={id:this.nextPingID++,promise:new Promise((n,i)=>{let o=()=>{i(new a("muxer closed locally",P))};this.closeController.signal.addEventListener("abort",o,{once:!0}),t=()=>{this.closeController.signal.removeEventListener("abort",o),n()}}),resolve:t};let e=Date.now();this.sendPing(this.activePing.id);try{await this.activePing.promise}finally{delete this.activePing}let r=Date.now();this.rtt=r-e}else await this.activePing.promise;return this.rtt}getRTT(){return this.rtt}async close(t={}){if(this.closeController.signal.aborted)return;let e=t?.reason??m.NormalTermination;if(this.log?.trace("muxer close reason=%s",e),t.signal==null){let r=AbortSignal.timeout(Xt);q(1/0,r),t={...t,signal:r}}try{await Promise.all([...this._streams.values()].map(async r=>r.close(t))),this.sendGoAway(e),this._closeMuxer()}catch(r){this.abort(r)}}abort(t,e){if(!this.closeController.signal.aborted){e=e??m.InternalError,this.log?.error("muxer abort reason=%s error=%s",e,t);for(let r of this._streams.values())r.abort(t);this.sendGoAway(e),this._closeMuxer()}}isClosed(){return this.closeController.signal.aborted}_closeMuxer(){this.closeController.abort(),this.source.end()}_newStream(t,e,r,n){if(this._streams.get(t)!=null)throw new a("Stream already exists",J,{id:t});let i=new X({id:t.toString(),name:e,state:r,direction:n,sendFrame:this.sendFrame.bind(this),onEnd:()=>{this.closeStream(t),this.onStreamEnd?.(i)},log:this.logger.forComponent(`libp2p:yamux:${n}:${t}`),config:this.config,getRTT:this.getRTT.bind(this)});return i}closeStream(t){this.client===(t%2===0)?this.numInboundStreams--:this.numOutboundStreams--,this._streams.delete(t)}async keepAliveLoop(){let t=new Promise((e,r)=>{this.closeController.signal.addEventListener("abort",r,{once:!0})});for(this.log?.trace("muxer keepalive enabled interval=%s",this.config.keepAliveInterval);;){let e;try{await Promise.race([t,new Promise(r=>{e=setTimeout(r,this.config.keepAliveInterval)})]),this.ping().catch(r=>this.log?.error("ping error: %s",r))}catch{clearInterval(e);return}}}async handleFrame(t,e){let{streamID:r,type:n,length:i}=t;if(this.log?.trace("received frame %o",t),r===0)switch(n){case f.Ping:{this.handlePing(t);return}case f.GoAway:{this.handleGoAway(i);return}default:throw new a("Invalid frame type",D,{header:t})}else switch(t.type){case f.Data:case f.WindowUpdate:{await this.handleStreamMessage(t,e);return}default:throw new a("Invalid frame type",D,{header:t})}}handlePing(t){if(t.flag===c.SYN)this.log?.trace("received ping request pingId=%s",t.length),this.sendPing(t.length,c.ACK);else if(t.flag===c.ACK)this.log?.trace("received ping response pingId=%s",t.length),this.handlePingResponse(t.length);else throw new a("Invalid frame flag",D,{header:t})}handlePingResponse(t){if(this.activePing===void 0)throw new a("ping not requested",j);if(this.activePing.id!==t)throw new a("ping doesn't match our id",Q);this.activePing.resolve()}handleGoAway(t){this.log?.trace("received GoAway reason=%s",m[t]??"unknown"),this.remoteGoAway=t;for(let e of this._streams.values())e.reset();this._closeMuxer()}async handleStreamMessage(t,e){let{streamID:r,flag:n,type:i}=t;(n&c.SYN)===c.SYN&&this.incomingStream(r);let o=this._streams.get(r);if(o===void 0){if(i===f.Data){if(this.log?.("discarding data for stream id=%s",r),e===void 0)throw new Error("unreachable");await e()}else this.log?.("frame for missing stream id=%s",r);return}switch(i){case f.WindowUpdate:{o.handleWindowUpdate(t);return}case f.Data:{if(e===void 0)throw new Error("unreachable");await o.handleData(t,e);return}default:throw new Error("unreachable")}}incomingStream(t){if(this.client!==(t%2===0))throw new a("both endpoints are clients",tt);if(this._streams.has(t))return;if(this.log?.trace("new incoming stream id=%s",t),this.localGoAway!==void 0){this.sendFrame({type:f.WindowUpdate,flag:c.RST,streamID:t,length:0});return}if(this.numInboundStreams>=this.config.maxInboundStreams){this.log?.("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:f.WindowUpdate,flag:c.RST,streamID:t,length:0});return}let e=this._newStream(t,void 0,p.SYNReceived,"inbound");this.numInboundStreams++,this._streams.set(t,e),this.onIncomingStream?.(e)}sendFrame(t,e){if(this.log?.trace("sending frame %o",t),t.type===f.Data){if(e===void 0)throw new a("invalid frame",D);this.source.push(new E(st(t),e))}else this.source.push(st(t))}sendPing(t,e=c.SYN){e===c.SYN?this.log?.trace("sending ping request pingId=%s",t):this.log?.trace("sending ping response pingId=%s",t),this.sendFrame({type:f.Ping,flag:e,streamID:0,length:t})}sendGoAway(t=m.NormalTermination){this.log?.("sending GoAway reason=%s",m[t]),this.localGoAway=t,this.sendFrame({type:f.GoAway,flag:0,streamID:0,length:t})}};function zt(s){return s!=null&&typeof s.then=="function"}function Yt(s={}){return t=>new z(t,s)}return Ot(Ht);})();
return ChainsafeLibp2PYamux}));
