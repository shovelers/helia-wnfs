import type { InfiniteHash } from './consumable-hash.js';
export interface BucketChild<V> {
    key: string;
    value: V;
    hash: InfiniteHash;
}
interface SA<B> {
    length: number;
    compactArray: () => B[];
    get: (i: number) => B;
    set: (i: number, value: B) => void;
    reduce: <A>(fn: (acc: A, curr: B, index: number) => A, initial: A) => B;
    find: (fn: (item: B) => boolean) => B | undefined;
    bitField: () => number[];
    unset: (i: number) => void;
}
export interface BucketPosition<T> {
    bucket: Bucket<T>;
    pos: number;
    hash: InfiniteHash;
    existingChild?: BucketChild<T>;
}
export interface BucketOptions {
    bits: number;
    hash: (value: Uint8Array | InfiniteHash) => InfiniteHash;
}
export declare class Bucket<T> {
    _options: BucketOptions;
    _popCount: number;
    _parent?: Bucket<T>;
    _posAtParent: number;
    _children: SA<Bucket<T> | BucketChild<T>>;
    key: string | null;
    constructor(options: BucketOptions, parent?: Bucket<T>, posAtParent?: number);
    put(key: string, value: T): Promise<void>;
    get(key: string): Promise<T | undefined>;
    del(key: string): Promise<void>;
    leafCount(): number;
    childrenCount(): number;
    onlyChild(): Bucket<T> | BucketChild<T>;
    eachLeafSeries(): Iterable<BucketChild<T>>;
    serialize(map: (value: BucketChild<T>, index: number) => T, reduce: (reduced: any) => any): any;
    asyncTransform(asyncMap: (value: BucketChild<T>) => Promise<T[]>, asyncReduce: (reduced: any) => Promise<any>): Promise<any>;
    toJSON(): any;
    prettyPrint(): string;
    tableSize(): number;
    _findChild(key: string): Promise<BucketChild<T> | undefined>;
    _findPlace(key: string | InfiniteHash): Promise<BucketPosition<T>>;
    _findNewBucketAndPos(key: string | InfiniteHash): Promise<BucketPosition<T>>;
    _putAt(place: BucketPosition<T>, key: string, value: T): void;
    _putObjectAt(pos: number, object: Bucket<T> | BucketChild<T>): void;
    _delAt(pos: number): void;
    _level(): void;
    _at(index: number): Bucket<T> | BucketChild<T>;
}
export {};
//# sourceMappingURL=bucket.d.ts.map