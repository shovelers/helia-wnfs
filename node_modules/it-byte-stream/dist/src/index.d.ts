/**
 * @packageDocumentation
 *
 * This module makes it easy to send and receive bytes over streams.
 *
 * @example
 *
 * ```typescript
 * import { byteStream } from 'it-byte-stream'
 *
 * const stream = byteStream(duplex)
 *
 * // read the next chunk
 * const bytes = await stream.read()
 *
 * // read the next five bytes
 * const fiveBytes = await stream.read(5)
 *
 * // write bytes into the stream
 * await stream.write(Uint8Array.from([0, 1, 2, 3, 4]))
 * ```
 */
import { Uint8ArrayList } from 'uint8arraylist';
import type { Duplex } from 'it-stream-types';
export declare class CodeError extends Error {
    readonly code: string;
    constructor(message: string, code: string);
}
export declare class AbortError extends CodeError {
    readonly type: string;
    constructor(message: string);
}
export interface AbortOptions {
    signal?: AbortSignal;
}
export interface ByteStream<Stream = unknown> {
    /**
     * Read a set number of bytes from the stream
     */
    read(bytes?: number, options?: AbortOptions): Promise<Uint8ArrayList>;
    /**
     * Write the passed bytes to the stream
     */
    write(input: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<void>;
    /**
     * Returns the underlying stream
     */
    unwrap(): Stream;
}
export interface ByteStreamOpts {
    /**
     * After the stream is unwrapped, any bytes that have been read from the
     * incoming stream will be yielded in-order as `Uint8Array`(s).
     *
     * To yield a single `Uint8ArrayList` with all unread bytes instead, pass
     * `false` here.
     */
    yieldBytes?: boolean;
}
export declare function byteStream<Stream extends Duplex<any, any, any>>(duplex: Stream, opts?: ByteStreamOpts): ByteStream<Stream>;
//# sourceMappingURL=index.d.ts.map