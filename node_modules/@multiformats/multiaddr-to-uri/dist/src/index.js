import { multiaddr, protocols } from '@multiformats/multiaddr';
function extractSNI(ma) {
    let sniProtoCode;
    try {
        sniProtoCode = protocols('sni').code;
    }
    catch (e) {
        // No SNI protocol in multiaddr
        return null;
    }
    for (const [proto, value] of ma) {
        if (proto === sniProtoCode && value !== undefined) {
            return value;
        }
    }
    return null;
}
function hasTLS(ma) {
    return ma.some(([proto, _]) => proto === protocols('tls').code);
}
function interpretNext(headProtoCode, headProtoVal, restMa) {
    const interpreter = interpreters[protocols(headProtoCode).name];
    if (interpreter === undefined) {
        throw new Error(`Can't interpret protocol ${protocols(headProtoCode).name}`);
    }
    const restVal = interpreter(headProtoVal, restMa);
    if (headProtoCode === protocols('ip6').code) {
        return `[${restVal}]`;
    }
    return restVal;
}
const interpreters = {
    ip4: (value, restMa) => value,
    ip6: (value, restMa) => {
        if (restMa.length === 0) {
            return value;
        }
        return `[${value}]`;
    },
    tcp: (value, restMa) => {
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        return `tcp://${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}:${value}`;
    },
    udp: (value, restMa) => {
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        return `udp://${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}:${value}`;
    },
    dnsaddr: (value, restMa) => value,
    dns4: (value, restMa) => value,
    dns6: (value, restMa) => value,
    dns: (value, restMa) => value,
    ipfs: (value, restMa) => {
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/ipfs/${value}`;
    },
    p2p: (value, restMa) => {
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p/${value}`;
    },
    http: (value, restMa) => {
        const maHasTLS = hasTLS(restMa);
        const sni = extractSNI(restMa);
        if (maHasTLS && sni !== null) {
            return `https://${sni}`;
        }
        const protocol = maHasTLS ? 'https://' : 'http://';
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa);
        // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there
        baseVal = baseVal.replace('tcp://', '');
        return `${protocol}${baseVal}`;
    },
    tls: (value, restMa) => {
        // Noop, the parent context knows that it's tls. We don't need to do
        // anything here
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        return interpretNext(tailProto[0], tailProto[1] ?? '', restMa);
    },
    sni: (value, restMa) => {
        // Noop, the parent context uses the sni information, we don't need to do
        // anything here
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        return interpretNext(tailProto[0], tailProto[1] ?? '', restMa);
    },
    https: (value, restMa) => {
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa);
        // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there
        baseVal = baseVal.replace('tcp://', '');
        return `https://${baseVal}`;
    },
    ws: (value, restMa) => {
        const maHasTLS = hasTLS(restMa);
        const sni = extractSNI(restMa);
        if (maHasTLS && sni !== null) {
            return `wss://${sni}`;
        }
        const protocol = maHasTLS ? 'wss://' : 'ws://';
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa);
        // We are reinterpreting the base, so we need to remove the tcp:// if it's there
        baseVal = baseVal.replace('tcp://', '');
        return `${protocol}${baseVal}`;
    },
    wss: (value, restMa) => {
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa);
        // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there
        baseVal = baseVal.replace('tcp://', '');
        return `wss://${baseVal}`;
    },
    'p2p-websocket-star': (value, restMa) => {
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-websocket-star`;
    },
    'p2p-webrtc-star': (value, restMa) => {
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-webrtc-star`;
    },
    'p2p-webrtc-direct': (value, restMa) => {
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-webrtc-direct`;
    }
};
export function multiaddrToUri(input, opts) {
    const ma = multiaddr(input);
    const parts = ma.stringTuples();
    const head = parts.pop();
    if (head === undefined) {
        throw new Error('Unexpected end of multiaddr');
    }
    const protocol = protocols(head[0]);
    const interpreter = interpreters[protocol.name];
    if (interpreter == null) {
        throw new Error(`No interpreter found for ${protocol.name}`);
    }
    let uri = interpreter(head[1] ?? '', parts);
    if (opts?.assumeHttp !== false && head[0] === protocols('tcp').code) {
        // If rightmost proto is tcp, we assume http here
        uri = uri.replace('tcp://', 'http://');
        if (head[1] === '443' || head[1] === '80') {
            if (head[1] === '443') {
                uri = uri.replace('http://', 'https://');
            }
            // Drop the port
            uri = uri.substring(0, uri.lastIndexOf(':'));
        }
    }
    return uri;
}
//# sourceMappingURL=index.js.map