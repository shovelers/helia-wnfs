import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';
export class DataChannel extends EventTarget {
    binaryType;
    maxPacketLifeTime;
    maxRetransmits;
    negotiated;
    ordered;
    onbufferedamountlow;
    onclose;
    onclosing;
    onerror;
    onmessage;
    onopen;
    #dataChannel;
    #bufferedAmountLowThreshold;
    #readyState;
    constructor(dataChannel, dataChannelDict = {}) {
        super();
        this.#dataChannel = dataChannel;
        this.#readyState = 'connecting';
        this.#bufferedAmountLowThreshold = 0;
        this.binaryType = 'arraybuffer';
        this.#dataChannel.onOpen(() => {
            this.#readyState = 'open';
            this.dispatchEvent(new Event('open'));
        });
        this.#dataChannel.onClosed(() => {
            this.#readyState = 'closed';
            this.dispatchEvent(new Event('close'));
        });
        this.#dataChannel.onError((msg) => {
            this.#readyState = 'closed';
            this.dispatchEvent(new RTCErrorEvent('error', {
                error: new RTCError({
                    errorDetail: 'data-channel-failure'
                }, msg)
            }));
        });
        this.#dataChannel.onBufferedAmountLow(() => {
            this.dispatchEvent(new Event('bufferedamountlow'));
        });
        this.#dataChannel.onMessage((data) => {
            if (typeof data === 'string') {
                data = uint8ArrayFromString(data);
            }
            this.dispatchEvent(new MessageEvent('message', { data }));
        });
        // forward events to properties
        this.addEventListener('message', event => {
            this.onmessage?.(event);
        });
        this.addEventListener('bufferedamountlow', event => {
            this.onbufferedamountlow?.(event);
        });
        this.addEventListener('error', event => {
            this.onerror?.(event);
        });
        this.addEventListener('close', event => {
            this.onclose?.(event);
        });
        this.addEventListener('closing', event => {
            this.onclosing?.(event);
        });
        this.addEventListener('open', event => {
            this.onopen?.(event);
        });
        this.onbufferedamountlow = null;
        this.onclose = null;
        this.onclosing = null;
        this.onerror = null;
        this.onmessage = null;
        this.onopen = null;
        this.maxPacketLifeTime = dataChannelDict.maxPacketLifeTime ?? null;
        this.maxRetransmits = dataChannelDict.maxRetransmits ?? null;
        this.negotiated = dataChannelDict.negotiated ?? false;
        this.ordered = dataChannelDict.ordered ?? true;
    }
    get id() {
        return this.#dataChannel.getId();
    }
    get label() {
        return this.#dataChannel.getLabel();
    }
    get protocol() {
        return this.#dataChannel.getProtocol();
    }
    get bufferedAmount() {
        return this.#dataChannel.bufferedAmount();
    }
    set bufferedAmountLowThreshold(threshold) {
        this.#bufferedAmountLowThreshold = threshold;
        this.#dataChannel.setBufferedAmountLowThreshold(threshold);
    }
    get bufferedAmountLowThreshold() {
        return this.#bufferedAmountLowThreshold;
    }
    get readyState() {
        return this.#readyState;
    }
    close() {
        this.#readyState = 'closing';
        this.dispatchEvent(new Event('closing'));
        this.#dataChannel.close();
    }
    send(data) {
        // TODO: sending Blobs
        if (typeof data === 'string') {
            this.#dataChannel.sendMessage(data);
        }
        else {
            this.#dataChannel.sendMessageBinary(data);
        }
    }
}
//# sourceMappingURL=rtc-data-channel.js.map