import node from 'node-datachannel';
import defer, {} from 'p-defer';
import { DataChannel } from './rtc-data-channel.js';
import { DataChannelEvent, PeerConnectionIceEvent } from './rtc-events.js';
import { IceCandidate } from './rtc-ice-candidate.js';
import { SessionDescription } from './rtc-session-description.js';
export class PeerConnection extends EventTarget {
    static async generateCertificate(keygenAlgorithm) {
        throw new Error('Not implemented');
    }
    canTrickleIceCandidates;
    sctp;
    onconnectionstatechange;
    ondatachannel;
    onicecandidate;
    onicecandidateerror;
    oniceconnectionstatechange;
    onicegatheringstatechange;
    onnegotiationneeded;
    onsignalingstatechange;
    ontrack;
    #peerConnection;
    #config;
    #localOffer;
    #localAnswer;
    #dataChannels;
    constructor(init = {}) {
        super();
        this.#config = init;
        this.#localOffer = defer();
        this.#localAnswer = defer();
        this.#dataChannels = new Set();
        const iceServers = init.iceServers ?? [];
        this.#peerConnection = new node.PeerConnection(`peer-${Math.random()}`, {
            iceServers: iceServers.map(server => {
                const urls = (Array.isArray(server.urls) ? server.urls : [server.urls]).map(str => new URL(str));
                return urls.map(url => {
                    /** @type {import('../lib/index.js').IceServer} */
                    const iceServer = {
                        hostname: url.hostname,
                        port: parseInt(url.port, 10),
                        username: server.username,
                        password: server.credential
                        // relayType - how to specify?
                    };
                    return iceServer;
                });
            })
                .flat(),
            iceTransportPolicy: init?.iceTransportPolicy
        });
        this.#peerConnection.onStateChange(() => {
            this.dispatchEvent(new Event('connectionstatechange'));
        });
        // https://github.com/murat-dogan/node-datachannel/pull/171
        // this.#peerConnection.onSignalingStateChange(() => {
        //  this.dispatchEvent(new Event('signalingstatechange'))
        // })
        this.#peerConnection.onGatheringStateChange(() => {
            this.dispatchEvent(new Event('icegatheringstatechange'));
        });
        this.#peerConnection.onDataChannel(channel => {
            this.dispatchEvent(new DataChannelEvent(new DataChannel(channel)));
        });
        // forward events to properties
        this.addEventListener('connectionstatechange', event => {
            this.onconnectionstatechange?.(event);
        });
        this.addEventListener('signalingstatechange', event => {
            this.onsignalingstatechange?.(event);
        });
        this.addEventListener('icegatheringstatechange', event => {
            this.onicegatheringstatechange?.(event);
        });
        this.addEventListener('datachannel', event => {
            this.ondatachannel?.(event);
        });
        this.#peerConnection.onLocalDescription((sdp, type) => {
            if (type === 'offer') {
                this.#localOffer.resolve({
                    sdp,
                    type
                });
            }
            if (type === 'answer') {
                this.#localAnswer.resolve({
                    sdp,
                    type
                });
            }
        });
        this.#peerConnection.onLocalCandidate((candidate, mid) => {
            if (mid === 'unspec') {
                this.#localAnswer.reject(new Error(`Invalid description type ${mid}`));
                return;
            }
            const event = new PeerConnectionIceEvent(new IceCandidate({ candidate }));
            this.onicecandidate?.(event);
        });
        this.canTrickleIceCandidates = null;
        this.sctp = null;
        this.onconnectionstatechange = null;
        this.ondatachannel = null;
        this.onicecandidate = null;
        this.onicecandidateerror = null;
        this.oniceconnectionstatechange = null;
        this.onicegatheringstatechange = null;
        this.onnegotiationneeded = null;
        this.onsignalingstatechange = null;
        this.ontrack = null;
    }
    get connectionState() {
        return assertState(this.#peerConnection.state(), RTCPeerConnectionStates);
    }
    get iceConnectionState() {
        return assertState(this.#peerConnection.state(), RTCIceConnectionStates);
    }
    get iceGatheringState() {
        return assertState(this.#peerConnection.gatheringState(), RTCIceGatheringStates);
    }
    get signalingState() {
        return assertState(this.#peerConnection.signalingState(), RTCSignalingStates);
    }
    get currentLocalDescription() {
        return toSessionDescription(this.#peerConnection.localDescription());
    }
    get localDescription() {
        return toSessionDescription(this.#peerConnection.localDescription());
    }
    get pendingLocalDescription() {
        return toSessionDescription(this.#peerConnection.localDescription());
    }
    get currentRemoteDescription() {
        // not exposed by node-datachannel
        return toSessionDescription(null);
    }
    get pendingRemoteDescription() {
        // not exposed by node-datachannel
        return toSessionDescription(null);
    }
    get remoteDescription() {
        // not exposed by node-datachannel
        return toSessionDescription(null);
    }
    async addIceCandidate(candidate) {
        if (candidate == null || candidate.candidate == null) {
            throw new Error('Candidate invalid');
        }
        this.#peerConnection.addRemoteCandidate(candidate.candidate, candidate.sdpMid ?? '0');
    }
    addTrack(track, ...streams) {
        throw new Error('Not implemented');
    }
    addTransceiver(trackOrKind, init) {
        throw new Error('Not implemented');
    }
    close() {
        // close all channels before shutting down
        this.#dataChannels.forEach(channel => {
            channel.close();
        });
        this.#peerConnection.close();
        this.#peerConnection.destroy();
    }
    createDataChannel(label, dataChannelDict = {}) {
        const channel = this.#peerConnection.createDataChannel(label, dataChannelDict);
        const dataChannel = new DataChannel(channel, dataChannelDict);
        // ensure we can close all channels when shutting down
        this.#dataChannels.add(dataChannel);
        dataChannel.addEventListener('close', () => {
            this.#dataChannels.delete(dataChannel);
        });
        return dataChannel;
    }
    async createOffer(...args) {
        return this.#localOffer.promise;
    }
    async createAnswer(...args) {
        return this.#localAnswer.promise;
    }
    getConfiguration() {
        return this.#config;
    }
    getReceivers() {
        throw new Error('Not implemented');
    }
    getSenders() {
        throw new Error('Not implemented');
    }
    async getStats(selector) {
        throw new Error('Not implemented');
    }
    getTransceivers() {
        throw new Error('Not implemented');
    }
    removeTrack(sender) {
        throw new Error('Not implemented');
    }
    restartIce() {
        throw new Error('Not implemented');
    }
    setConfiguration(configuration = {}) {
        this.#config = configuration;
    }
    async setLocalDescription(description) {
        if (description == null || description.type == null) {
            throw new Error('Local description type must be set');
        }
        if (description.type !== 'offer') {
            // any other type causes libdatachannel to throw
            return;
        }
        // @ts-expect-error types are wrong
        this.#peerConnection.setLocalDescription(description.type);
    }
    async setRemoteDescription(description) {
        if (description.sdp == null) {
            throw new Error('Remote SDP must be set');
        }
        // @ts-expect-error types are wrong
        this.#peerConnection.setRemoteDescription(description.sdp, description.type);
    }
}
export { PeerConnection as RTCPeerConnection };
function assertState(state, states) {
    if (state != null && !states.includes(state)) {
        throw new Error(`Invalid value encountered - "${state}" must be one of ${states}`);
    }
    return state;
}
function toSessionDescription(description) {
    if (description == null) {
        return null;
    }
    return new SessionDescription({
        sdp: description.sdp,
        type: assertState(description.type, RTCSdpTypes)
    });
}
const RTCPeerConnectionStates = ['closed', 'connected', 'connecting', 'disconnected', 'failed', 'new'];
const RTCSdpTypes = ['answer', 'offer', 'pranswer', 'rollback'];
const RTCIceConnectionStates = ['checking', 'closed', 'completed', 'connected', 'disconnected', 'failed', 'new'];
const RTCIceGatheringStates = ['complete', 'gathering', 'new'];
const RTCSignalingStates = ['closed', 'have-local-offer', 'have-local-pranswer', 'have-remote-offer', 'have-remote-pranswer', 'stable'];
//# sourceMappingURL=rtc-peer-connection.js.map