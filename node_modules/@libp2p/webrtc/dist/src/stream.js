import { CodeError } from '@libp2p/interface/errors';
import { AbstractStream } from '@libp2p/interface/stream-muxer/stream';
import { logger } from '@libp2p/logger';
import * as lengthPrefixed from 'it-length-prefixed';
import { pushable } from 'it-pushable';
import pDefer from 'p-defer';
import { pEvent, TimeoutError } from 'p-event';
import pTimeout from 'p-timeout';
import { raceSignal } from 'race-signal';
import { Uint8ArrayList } from 'uint8arraylist';
import { Message } from './pb/message.js';
/**
 * How much can be buffered to the DataChannel at once
 */
export const MAX_BUFFERED_AMOUNT = 16 * 1024 * 1024;
/**
 * How long time we wait for the 'bufferedamountlow' event to be emitted
 */
export const BUFFERED_AMOUNT_LOW_TIMEOUT = 30 * 1000;
/**
 * protobuf field definition overhead
 */
export const PROTOBUF_OVERHEAD = 5;
/**
 * Length of varint, in bytes
 */
export const VARINT_LENGTH = 2;
/**
 * Max message size that can be sent to the DataChannel
 */
export const MAX_MESSAGE_SIZE = 16 * 1024;
/**
 * When closing streams we send a FIN then wait for the remote to
 * reply with a FIN_ACK. If that does not happen within this timeout
 * we close the stream anyway.
 */
export const FIN_ACK_TIMEOUT = 5000;
export class WebRTCStream extends AbstractStream {
    /**
     * The data channel used to send and receive data
     */
    channel;
    /**
     * push data from the underlying datachannel to the length prefix decoder
     * and then the protobuf decoder.
     */
    incomingData;
    messageQueue;
    maxBufferedAmount;
    bufferedAmountLowEventTimeout;
    /**
     * The maximum size of a message in bytes
     */
    maxMessageSize;
    /**
     * When this promise is resolved, the remote has sent us a FIN flag
     */
    receiveFinAck;
    finAckTimeout;
    constructor(init) {
        // override onEnd to send/receive FIN_ACK before closing the stream
        const originalOnEnd = init.onEnd;
        init.onEnd = (err) => {
            this.log.trace('readable and writeable ends closed', this.status);
            void Promise.resolve(async () => {
                if (this.timeline.abort != null || this.timeline.reset !== null) {
                    return;
                }
                // wait for FIN_ACK if we haven't received it already
                try {
                    await pTimeout(this.receiveFinAck.promise, {
                        milliseconds: this.finAckTimeout
                    });
                }
                catch (err) {
                    this.log.error('error receiving FIN_ACK', err);
                }
            })
                .then(() => {
                // stop processing incoming messages
                this.incomingData.end();
                // final cleanup
                originalOnEnd?.(err);
            })
                .catch(err => {
                this.log.error('error ending stream', err);
            });
        };
        super(init);
        this.channel = init.channel;
        this.channel.binaryType = 'arraybuffer';
        this.incomingData = pushable();
        this.messageQueue = new Uint8ArrayList();
        this.bufferedAmountLowEventTimeout = init.bufferedAmountLowEventTimeout ?? BUFFERED_AMOUNT_LOW_TIMEOUT;
        this.maxBufferedAmount = init.maxBufferedAmount ?? MAX_BUFFERED_AMOUNT;
        this.maxMessageSize = (init.maxMessageSize ?? MAX_MESSAGE_SIZE) - PROTOBUF_OVERHEAD - VARINT_LENGTH;
        this.receiveFinAck = pDefer();
        this.finAckTimeout = init.closeTimeout ?? FIN_ACK_TIMEOUT;
        // set up initial state
        switch (this.channel.readyState) {
            case 'open':
                break;
            case 'closed':
            case 'closing':
                if (this.timeline.close === undefined || this.timeline.close === 0) {
                    this.timeline.close = Date.now();
                }
                break;
            case 'connecting':
                // noop
                break;
            default:
                this.log.error('unknown datachannel state %s', this.channel.readyState);
                throw new CodeError('Unknown datachannel state', 'ERR_INVALID_STATE');
        }
        // handle RTCDataChannel events
        this.channel.onopen = (_evt) => {
            this.timeline.open = new Date().getTime();
            if (this.messageQueue != null && this.messageQueue.byteLength > 0) {
                this.log.trace('dataChannel opened, sending queued messages', this.messageQueue.byteLength, this.channel.readyState);
                // send any queued messages
                this._sendMessage(this.messageQueue)
                    .catch(err => {
                    this.log.error('error sending queued messages', err);
                    this.abort(err);
                });
            }
            this.messageQueue = undefined;
        };
        this.channel.onclose = (_evt) => {
            // if the channel has closed we'll never receive a FIN_ACK so resolve the
            // promise so we don't try to wait later
            this.receiveFinAck.resolve();
            void this.close().catch(err => {
                this.log.error('error closing stream after channel closed', err);
            });
        };
        this.channel.onerror = (evt) => {
            const err = evt.error;
            this.abort(err);
        };
        this.channel.onmessage = async (event) => {
            const { data } = event;
            if (data === null || data.byteLength === 0) {
                return;
            }
            this.incomingData.push(new Uint8Array(data, 0, data.byteLength));
        };
        const self = this;
        // pipe framed protobuf messages through a length prefixed decoder, and
        // surface data from the `Message.message` field through a source.
        Promise.resolve().then(async () => {
            for await (const buf of lengthPrefixed.decode(this.incomingData)) {
                const message = self.processIncomingProtobuf(buf);
                if (message != null) {
                    self.sourcePush(new Uint8ArrayList(message));
                }
            }
        })
            .catch(err => {
            this.log.error('error processing incoming data channel messages', err);
        });
    }
    sendNewStream() {
        // opening new streams is handled by WebRTC so this is a noop
    }
    async _sendMessage(data, checkBuffer = true) {
        if (checkBuffer && this.channel.bufferedAmount > this.maxBufferedAmount) {
            try {
                await pEvent(this.channel, 'bufferedamountlow', { timeout: this.bufferedAmountLowEventTimeout });
            }
            catch (err) {
                if (err instanceof TimeoutError) {
                    throw new CodeError(`Timed out waiting for DataChannel buffer to clear after ${this.bufferedAmountLowEventTimeout}ms`, 'ERR_BUFFER_CLEAR_TIMEOUT');
                }
                throw err;
            }
        }
        if (this.channel.readyState === 'closed' || this.channel.readyState === 'closing') {
            throw new CodeError(`Invalid datachannel state - ${this.channel.readyState}`, 'ERR_INVALID_STATE');
        }
        if (this.channel.readyState === 'open') {
            // send message without copying data
            for (const buf of data) {
                this.channel.send(buf);
            }
        }
        else if (this.channel.readyState === 'connecting') {
            // queue message for when we are open
            if (this.messageQueue == null) {
                this.messageQueue = new Uint8ArrayList();
            }
            this.messageQueue.append(data);
        }
        else {
            this.log.error('unknown datachannel state %s', this.channel.readyState);
            throw new CodeError('Unknown datachannel state', 'ERR_INVALID_STATE');
        }
    }
    async sendData(data) {
        // sending messages is an async operation so use a copy of the list as it
        // may be changed beneath us
        data = data.sublist();
        while (data.byteLength > 0) {
            const toSend = Math.min(data.byteLength, this.maxMessageSize);
            const buf = data.subarray(0, toSend);
            const msgbuf = Message.encode({ message: buf });
            const sendbuf = lengthPrefixed.encode.single(msgbuf);
            await this._sendMessage(sendbuf);
            data.consume(toSend);
        }
    }
    async sendReset() {
        await this._sendFlag(Message.Flag.RESET);
    }
    async sendCloseWrite(options) {
        const sent = await this._sendFlag(Message.Flag.FIN);
        if (sent) {
            this.log.trace('awaiting FIN_ACK');
            try {
                await raceSignal(this.receiveFinAck.promise, options?.signal, {
                    errorMessage: 'sending close-write was aborted before FIN_ACK was received',
                    errorCode: 'ERR_FIN_ACK_NOT_RECEIVED'
                });
            }
            catch (err) {
                this.log.error('failed to await FIN_ACK', err);
            }
        }
        else {
            this.log.trace('sending FIN failed, not awaiting FIN_ACK');
        }
        // if we've attempted to receive a FIN_ACK, do not try again
        this.receiveFinAck.resolve();
    }
    async sendCloseRead() {
        await this._sendFlag(Message.Flag.STOP_SENDING);
    }
    /**
     * Handle incoming
     */
    processIncomingProtobuf(buffer) {
        const message = Message.decode(buffer);
        if (message.flag !== undefined) {
            this.log.trace('incoming flag %s, write status "%s", read status "%s"', message.flag, this.writeStatus, this.readStatus);
            if (message.flag === Message.Flag.FIN) {
                // We should expect no more data from the remote, stop reading
                this.remoteCloseWrite();
                this.log.trace('sending FIN_ACK');
                void this._sendFlag(Message.Flag.FIN_ACK)
                    .catch(err => {
                    this.log.error('error sending FIN_ACK immediately', err);
                });
            }
            if (message.flag === Message.Flag.RESET) {
                // Stop reading and writing to the stream immediately
                this.reset();
            }
            if (message.flag === Message.Flag.STOP_SENDING) {
                // The remote has stopped reading
                this.remoteCloseRead();
            }
            if (message.flag === Message.Flag.FIN_ACK) {
                this.log.trace('received FIN_ACK');
                this.receiveFinAck.resolve();
            }
        }
        // ignore data messages if we've closed the readable end already
        if (this.readStatus === 'ready') {
            return message.message;
        }
    }
    async _sendFlag(flag) {
        if (this.channel.readyState !== 'open') {
            // flags can be sent while we or the remote are closing the datachannel so
            // if the channel isn't open, don't try to send it but return false to let
            // the caller know and act if they need to
            this.log.trace('not sending flag %s because channel is not open', flag.toString());
            return false;
        }
        this.log.trace('sending flag %s', flag.toString());
        const msgbuf = Message.encode({ flag });
        const prefixedBuf = lengthPrefixed.encode.single(msgbuf);
        try {
            await this._sendMessage(prefixedBuf, false);
            return true;
        }
        catch (err) {
            this.log.error('could not send flag %s', flag.toString(), err);
        }
        return false;
    }
}
export function createStream(options) {
    const { channel, direction } = options;
    return new WebRTCStream({
        id: direction === 'inbound' ? (`i${channel.id}`) : `r${channel.id}`,
        log: logger(`libp2p:webrtc:stream:${direction}:${channel.id}`),
        ...options
    });
}
//# sourceMappingURL=stream.js.map