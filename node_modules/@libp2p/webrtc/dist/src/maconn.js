import { logger } from '@libp2p/logger';
import { nopSink, nopSource } from './util.js';
const log = logger('libp2p:webrtc:maconn');
export class WebRTCMultiaddrConnection {
    /**
     * WebRTC Peer Connection
     */
    peerConnection;
    /**
     * The multiaddr address used to communicate with the remote peer
     */
    remoteAddr;
    /**
     * Holds the lifecycle times of the connection
     */
    timeline;
    /**
     * Optional metrics counter group for this connection
     */
    metrics;
    /**
     * The stream source, a no-op as the transport natively supports multiplexing
     */
    source = nopSource();
    /**
     * The stream destination, a no-op as the transport natively supports multiplexing
     */
    sink = nopSink;
    constructor(init) {
        this.remoteAddr = init.remoteAddr;
        this.timeline = init.timeline;
        this.peerConnection = init.peerConnection;
        const initialState = this.peerConnection.connectionState;
        this.peerConnection.onconnectionstatechange = () => {
            log.trace('peer connection state change', this.peerConnection.connectionState, 'initial state', initialState);
            if (this.peerConnection.connectionState === 'disconnected' || this.peerConnection.connectionState === 'failed' || this.peerConnection.connectionState === 'closed') {
                // nothing else to do but close the connection
                this.timeline.close = Date.now();
            }
        };
    }
    async close(options) {
        log.trace('closing connection');
        this.peerConnection.close();
        this.timeline.close = Date.now();
        this.metrics?.increment({ close: true });
    }
    abort(err) {
        log.error('closing connection due to error', err);
        this.peerConnection.close();
        this.timeline.close = Date.now();
        this.metrics?.increment({ abort: true });
    }
}
//# sourceMappingURL=maconn.js.map