import type { DataChannelOptions } from './index.js';
import type { Stream } from '@libp2p/interface/connection';
import type { CounterGroup } from '@libp2p/interface/metrics';
import type { StreamMuxer, StreamMuxerFactory, StreamMuxerInit } from '@libp2p/interface/stream-muxer';
import type { AbortOptions } from '@multiformats/multiaddr';
import type { Source, Sink } from 'it-stream-types';
import type { Uint8ArrayList } from 'uint8arraylist';
export interface DataChannelMuxerFactoryInit {
    /**
     * WebRTC Peer Connection
     */
    peerConnection: RTCPeerConnection;
    /**
     * The protocol to use
     */
    protocol?: string;
    /**
     * Optional metrics for this data channel muxer
     */
    metrics?: CounterGroup;
    dataChannelOptions?: DataChannelOptions;
}
interface BufferedStream {
    stream: Stream;
    channel: RTCDataChannel;
    onEnd(err?: Error): void;
}
export declare class DataChannelMuxerFactory implements StreamMuxerFactory {
    readonly protocol: string;
    /**
     * WebRTC Peer Connection
     */
    private readonly peerConnection;
    private bufferedStreams;
    private readonly metrics?;
    private readonly dataChannelOptions?;
    constructor(init: DataChannelMuxerFactoryInit);
    createStreamMuxer(init?: StreamMuxerInit): StreamMuxer;
}
export interface DataChannelMuxerInit extends DataChannelMuxerFactoryInit, StreamMuxerInit {
    streams: BufferedStream[];
}
/**
 * A libp2p data channel stream muxer
 */
export declare class DataChannelMuxer implements StreamMuxer {
    #private;
    readonly init: DataChannelMuxerInit;
    /**
     * Array of streams in the data channel
     */
    streams: Stream[];
    protocol: string;
    private readonly peerConnection;
    private readonly dataChannelOptions;
    private readonly metrics?;
    constructor(init: DataChannelMuxerInit);
    /**
     * Gracefully close all tracked streams and stop the muxer
     */
    close(options?: AbortOptions): Promise<void>;
    /**
     * Abort all tracked streams and stop the muxer
     */
    abort(err: Error): void;
    /**
     * The stream source, a no-op as the transport natively supports multiplexing
     */
    source: AsyncGenerator<Uint8Array, any, unknown>;
    /**
     * The stream destination, a no-op as the transport natively supports multiplexing
     */
    sink: Sink<Source<Uint8Array | Uint8ArrayList>, Promise<void>>;
    newStream(): Stream;
}
export {};
//# sourceMappingURL=muxer.d.ts.map