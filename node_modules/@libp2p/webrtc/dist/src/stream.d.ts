import { AbstractStream, type AbstractStreamInit } from '@libp2p/interface/stream-muxer/stream';
import { Uint8ArrayList } from 'uint8arraylist';
import type { DataChannelOptions } from './index.js';
import type { AbortOptions } from '@libp2p/interface';
import type { Direction } from '@libp2p/interface/connection';
export interface WebRTCStreamInit extends AbstractStreamInit, DataChannelOptions {
    /**
     * The network channel used for bidirectional peer-to-peer transfers of
     * arbitrary data
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel}
     */
    channel: RTCDataChannel;
}
/**
 * How much can be buffered to the DataChannel at once
 */
export declare const MAX_BUFFERED_AMOUNT: number;
/**
 * How long time we wait for the 'bufferedamountlow' event to be emitted
 */
export declare const BUFFERED_AMOUNT_LOW_TIMEOUT: number;
/**
 * protobuf field definition overhead
 */
export declare const PROTOBUF_OVERHEAD = 5;
/**
 * Length of varint, in bytes
 */
export declare const VARINT_LENGTH = 2;
/**
 * Max message size that can be sent to the DataChannel
 */
export declare const MAX_MESSAGE_SIZE: number;
/**
 * When closing streams we send a FIN then wait for the remote to
 * reply with a FIN_ACK. If that does not happen within this timeout
 * we close the stream anyway.
 */
export declare const FIN_ACK_TIMEOUT = 5000;
export declare class WebRTCStream extends AbstractStream {
    /**
     * The data channel used to send and receive data
     */
    private readonly channel;
    /**
     * push data from the underlying datachannel to the length prefix decoder
     * and then the protobuf decoder.
     */
    private readonly incomingData;
    private messageQueue?;
    private readonly maxBufferedAmount;
    private readonly bufferedAmountLowEventTimeout;
    /**
     * The maximum size of a message in bytes
     */
    private readonly maxMessageSize;
    /**
     * When this promise is resolved, the remote has sent us a FIN flag
     */
    private readonly receiveFinAck;
    private readonly finAckTimeout;
    constructor(init: WebRTCStreamInit);
    sendNewStream(): void;
    _sendMessage(data: Uint8ArrayList, checkBuffer?: boolean): Promise<void>;
    sendData(data: Uint8ArrayList): Promise<void>;
    sendReset(): Promise<void>;
    sendCloseWrite(options: AbortOptions): Promise<void>;
    sendCloseRead(): Promise<void>;
    /**
     * Handle incoming
     */
    private processIncomingProtobuf;
    private _sendFlag;
}
export interface WebRTCStreamOptions extends DataChannelOptions {
    /**
     * The network channel used for bidirectional peer-to-peer transfers of
     * arbitrary data
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel}
     */
    channel: RTCDataChannel;
    /**
     * The stream direction
     */
    direction: Direction;
    /**
     * A callback invoked when the channel ends
     */
    onEnd?(err?: Error | undefined): void;
}
export declare function createStream(options: WebRTCStreamOptions): WebRTCStream;
//# sourceMappingURL=stream.d.ts.map