import { CodeError } from '@libp2p/interface/errors';
import { symbol } from '@libp2p/interface/transport';
import { logger } from '@libp2p/logger';
import { peerIdFromString } from '@libp2p/peer-id';
import { multiaddr } from '@multiformats/multiaddr';
import { WebRTC } from '@multiformats/multiaddr-matcher';
import { codes } from '../error.js';
import { WebRTCMultiaddrConnection } from '../maconn.js';
import { DataChannelMuxerFactory } from '../muxer.js';
import { cleanup, RTCPeerConnection } from '../webrtc/index.js';
import { initiateConnection } from './initiate-connection.js';
import { WebRTCPeerListener } from './listener.js';
import { handleIncomingStream } from './signaling-stream-handler.js';
const log = logger('libp2p:webrtc:peer');
const WEBRTC_TRANSPORT = '/webrtc';
const CIRCUIT_RELAY_TRANSPORT = '/p2p-circuit';
export const SIGNALING_PROTO_ID = '/webrtc-signaling/0.0.1';
const INBOUND_CONNECTION_TIMEOUT = 30 * 1000;
export class WebRTCTransport {
    components;
    init;
    _started = false;
    metrics;
    shutdownController;
    constructor(components, init = {}) {
        this.components = components;
        this.init = init;
        this.shutdownController = new AbortController();
        if (components.metrics != null) {
            this.metrics = {
                dialerEvents: components.metrics.registerCounterGroup('libp2p_webrtc_dialer_events_total', {
                    label: 'event',
                    help: 'Total count of WebRTC dialer events by type'
                }),
                listenerEvents: components.metrics.registerCounterGroup('libp2p_webrtc_listener_events_total', {
                    label: 'event',
                    help: 'Total count of WebRTC listener events by type'
                })
            };
        }
    }
    isStarted() {
        return this._started;
    }
    async start() {
        await this.components.registrar.handle(SIGNALING_PROTO_ID, (data) => {
            this._onProtocol(data).catch(err => { log.error('failed to handle incoming connect from %p', data.connection.remotePeer, err); });
        }, {
            runOnTransientConnection: true
        });
        this._started = true;
    }
    async stop() {
        await this.components.registrar.unhandle(SIGNALING_PROTO_ID);
        cleanup();
        this._started = false;
    }
    createListener(options) {
        return new WebRTCPeerListener(this.components, {
            shutdownController: this.shutdownController
        });
    }
    [Symbol.toStringTag] = '@libp2p/webrtc';
    [symbol] = true;
    filter(multiaddrs) {
        return multiaddrs.filter(WebRTC.exactMatch);
    }
    /*
     * dial connects to a remote via the circuit relay or any other protocol
     * and proceeds to upgrade to a webrtc connection.
     * multiaddr of the form: <multiaddr>/webrtc/p2p/<destination-peer>
     * For a circuit relay, this will be of the form
     * <relay address>/p2p/<relay-peer>/p2p-circuit/webrtc/p2p/<destination-peer>
    */
    async dial(ma, options) {
        log.trace('dialing address: %a', ma);
        const peerConnection = new RTCPeerConnection(this.init.rtcConfiguration);
        const muxerFactory = new DataChannelMuxerFactory({
            peerConnection,
            dataChannelOptions: this.init.dataChannel
        });
        const { remoteAddress } = await initiateConnection({
            peerConnection,
            multiaddr: ma,
            dataChannelOptions: this.init.dataChannel,
            signal: options.signal,
            connectionManager: this.components.connectionManager,
            transportManager: this.components.transportManager
        });
        const webRTCConn = new WebRTCMultiaddrConnection({
            peerConnection,
            timeline: { open: Date.now() },
            remoteAddr: remoteAddress,
            metrics: this.metrics?.dialerEvents
        });
        const connection = await options.upgrader.upgradeOutbound(webRTCConn, {
            skipProtection: true,
            skipEncryption: true,
            muxerFactory
        });
        // close the connection on shut down
        this._closeOnShutdown(peerConnection, webRTCConn);
        return connection;
    }
    async _onProtocol({ connection, stream }) {
        const signal = AbortSignal.timeout(this.init.inboundConnectionTimeout ?? INBOUND_CONNECTION_TIMEOUT);
        const peerConnection = new RTCPeerConnection(this.init.rtcConfiguration);
        const muxerFactory = new DataChannelMuxerFactory({
            peerConnection,
            dataChannelOptions: this.init.dataChannel
        });
        try {
            const { remoteAddress } = await handleIncomingStream({
                peerConnection,
                connection,
                stream,
                signal
            });
            const webRTCConn = new WebRTCMultiaddrConnection({
                peerConnection,
                timeline: { open: (new Date()).getTime() },
                remoteAddr: remoteAddress,
                metrics: this.metrics?.listenerEvents
            });
            // close the connection on shut down
            this._closeOnShutdown(peerConnection, webRTCConn);
            await this.components.upgrader.upgradeInbound(webRTCConn, {
                skipEncryption: true,
                skipProtection: true,
                muxerFactory
            });
            // close the stream if SDP messages have been exchanged successfully
            await stream.close({
                signal
            });
        }
        catch (err) {
            stream.abort(err);
            throw err;
        }
    }
    _closeOnShutdown(pc, webRTCConn) {
        // close the connection on shut down
        const shutDownListener = () => {
            webRTCConn.close()
                .catch(err => {
                log.error('could not close WebRTCMultiaddrConnection', err);
            });
        };
        this.shutdownController.signal.addEventListener('abort', shutDownListener);
        pc.addEventListener('close', () => {
            this.shutdownController.signal.removeEventListener('abort', shutDownListener);
        });
    }
}
export function splitAddr(ma) {
    const addrs = ma.toString().split(WEBRTC_TRANSPORT + '/');
    if (addrs.length !== 2) {
        throw new CodeError('webrtc protocol was not present in multiaddr', codes.ERR_INVALID_MULTIADDR);
    }
    if (!addrs[0].includes(CIRCUIT_RELAY_TRANSPORT)) {
        throw new CodeError('p2p-circuit protocol was not present in multiaddr', codes.ERR_INVALID_MULTIADDR);
    }
    // look for remote peerId
    let remoteAddr = multiaddr(addrs[0]);
    const destination = multiaddr('/' + addrs[1]);
    const destinationIdString = destination.getPeerId();
    if (destinationIdString == null) {
        throw new CodeError('destination peer id was missing', codes.ERR_INVALID_MULTIADDR);
    }
    const lastProtoInRemote = remoteAddr.protos().pop();
    if (lastProtoInRemote === undefined) {
        throw new CodeError('invalid multiaddr', codes.ERR_INVALID_MULTIADDR);
    }
    if (lastProtoInRemote.name !== 'p2p') {
        remoteAddr = remoteAddr.encapsulate(`/p2p/${destinationIdString}`);
    }
    return { baseAddr: remoteAddr, peerId: peerIdFromString(destinationIdString) };
}
//# sourceMappingURL=transport.js.map