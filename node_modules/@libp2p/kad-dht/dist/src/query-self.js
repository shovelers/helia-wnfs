import { setMaxListeners } from '@libp2p/interface/events';
import { logger } from '@libp2p/logger';
import { anySignal } from 'any-signal';
import length from 'it-length';
import { pipe } from 'it-pipe';
import take from 'it-take';
import pDefer from 'p-defer';
import { pEvent } from 'p-event';
import { QUERY_SELF_INTERVAL, QUERY_SELF_TIMEOUT, K, QUERY_SELF_INITIAL_INTERVAL } from './constants.js';
/**
 * Receives notifications of new peers joining the network that support the DHT protocol
 */
export class QuerySelf {
    log;
    components;
    peerRouting;
    routingTable;
    count;
    interval;
    initialInterval;
    queryTimeout;
    started;
    timeoutId;
    controller;
    initialQuerySelfHasRun;
    querySelfPromise;
    constructor(components, init) {
        const { peerRouting, lan, count, interval, queryTimeout, routingTable } = init;
        this.components = components;
        this.log = logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:query-self`);
        this.started = false;
        this.peerRouting = peerRouting;
        this.routingTable = routingTable;
        this.count = count ?? K;
        this.interval = interval ?? QUERY_SELF_INTERVAL;
        this.initialInterval = init.initialInterval ?? QUERY_SELF_INITIAL_INTERVAL;
        this.queryTimeout = queryTimeout ?? QUERY_SELF_TIMEOUT;
        this.initialQuerySelfHasRun = init.initialQuerySelfHasRun;
    }
    isStarted() {
        return this.started;
    }
    start() {
        if (this.started) {
            return;
        }
        this.started = true;
        clearTimeout(this.timeoutId);
        this.timeoutId = setTimeout(() => {
            this.querySelf()
                .catch(err => {
                this.log.error('error running self-query', err);
            });
        }, this.initialInterval);
    }
    stop() {
        this.started = false;
        if (this.timeoutId != null) {
            clearTimeout(this.timeoutId);
        }
        if (this.controller != null) {
            this.controller.abort();
        }
    }
    async querySelf() {
        if (!this.started) {
            this.log('skip self-query because we are not started');
            return;
        }
        if (this.querySelfPromise != null) {
            this.log('joining existing self query');
            return this.querySelfPromise.promise;
        }
        this.querySelfPromise = pDefer();
        if (this.started) {
            this.controller = new AbortController();
            const signal = anySignal([this.controller.signal, AbortSignal.timeout(this.queryTimeout)]);
            // this controller will get used for lots of dial attempts so make sure we don't cause warnings to be logged
            setMaxListeners(Infinity, signal);
            try {
                if (this.routingTable.size === 0) {
                    this.log('routing table was empty, waiting for some peers before running query');
                    // wait to discover at least one DHT peer
                    await pEvent(this.routingTable, 'peer:add', {
                        signal
                    });
                }
                this.log('run self-query, look for %d peers timing out after %dms', this.count, this.queryTimeout);
                const start = Date.now();
                const found = await pipe(this.peerRouting.getClosestPeers(this.components.peerId.toBytes(), {
                    signal,
                    isSelfQuery: true
                }), (source) => take(source, this.count), async (source) => length(source));
                this.log('self-query found %d peers in %dms', found, Date.now() - start);
            }
            catch (err) {
                this.log.error('self-query error', err);
            }
            finally {
                signal.clear();
                if (this.initialQuerySelfHasRun != null) {
                    this.initialQuerySelfHasRun.resolve();
                    this.initialQuerySelfHasRun = undefined;
                }
            }
        }
        this.querySelfPromise.resolve();
        this.querySelfPromise = undefined;
        if (!this.started) {
            return;
        }
        this.timeoutId = setTimeout(() => {
            this.querySelf()
                .catch(err => {
                this.log.error('error running self-query', err);
            });
        }, this.interval);
    }
}
//# sourceMappingURL=query-self.js.map