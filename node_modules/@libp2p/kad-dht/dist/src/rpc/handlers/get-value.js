import { CodeError } from '@libp2p/interface/errors';
import { logger } from '@libp2p/logger';
import { MAX_RECORD_AGE } from '../../constants.js';
import { Message, MESSAGE_TYPE } from '../../message/index.js';
import { Libp2pRecord } from '../../record/index.js';
import { bufferToRecordKey, isPublicKeyKey, fromPublicKeyKey } from '../../utils.js';
const log = logger('libp2p:kad-dht:rpc:handlers:get-value');
export class GetValueHandler {
    components;
    peerRouting;
    constructor(components, init) {
        const { peerRouting } = init;
        this.components = components;
        this.peerRouting = peerRouting;
    }
    async handle(peerId, msg) {
        const key = msg.key;
        log('%p asked for key %b', peerId, key);
        if (key == null || key.length === 0) {
            throw new CodeError('Invalid key', 'ERR_INVALID_KEY');
        }
        const response = new Message(MESSAGE_TYPE.GET_VALUE, key, msg.clusterLevel);
        if (isPublicKeyKey(key)) {
            log('is public key');
            const idFromKey = fromPublicKeyKey(key);
            let pubKey;
            try {
                const peer = await this.components.peerStore.get(idFromKey);
                if (peer.id.publicKey == null) {
                    throw new CodeError('No public key found in key book', 'ERR_NOT_FOUND');
                }
                pubKey = peer.id.publicKey;
            }
            catch (err) {
                if (err.code !== 'ERR_NOT_FOUND') {
                    throw err;
                }
            }
            if (pubKey != null) {
                log('returning found public key');
                response.record = new Libp2pRecord(key, pubKey, new Date());
                return response;
            }
        }
        const [record, closer] = await Promise.all([
            this._checkLocalDatastore(key),
            this.peerRouting.getCloserPeersOffline(msg.key, peerId)
        ]);
        if (record != null) {
            log('had record for %b in local datastore', key);
            response.record = record;
        }
        if (closer.length > 0) {
            log('had %s closer peers in routing table', closer.length);
            response.closerPeers = closer;
        }
        return response;
    }
    /**
     * Try to fetch a given record by from the local datastore.
     * Returns the record if it is still valid, meaning
     * - it was either authored by this node, or
     * - it was received less than `MAX_RECORD_AGE` ago.
     */
    async _checkLocalDatastore(key) {
        log('checkLocalDatastore looking for %b', key);
        const dsKey = bufferToRecordKey(key);
        // Fetch value from ds
        let rawRecord;
        try {
            rawRecord = await this.components.datastore.get(dsKey);
        }
        catch (err) {
            if (err.code === 'ERR_NOT_FOUND') {
                return undefined;
            }
            throw err;
        }
        // Create record from the returned bytes
        const record = Libp2pRecord.deserialize(rawRecord);
        if (record == null) {
            throw new CodeError('Invalid record', 'ERR_INVALID_RECORD');
        }
        // Check validity: compare time received with max record age
        if (record.timeReceived == null ||
            Date.now() - record.timeReceived.getTime() > MAX_RECORD_AGE) {
            // If record is bad delete it and return
            await this.components.datastore.delete(dsKey);
            return undefined;
        }
        // Record is valid
        return record;
    }
}
//# sourceMappingURL=get-value.js.map