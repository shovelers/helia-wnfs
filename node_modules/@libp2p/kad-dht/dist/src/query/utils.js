import { CodeError } from '@libp2p/interface/errors';
import { pushable } from 'it-pushable';
export async function* queueToGenerator(queue, signal, cleanUp, log) {
    const stream = pushable({
        objectMode: true
    });
    const cleanup = (err) => {
        log('clean up queue, results %d, queue size %d, pending tasks %d', stream.readableLength, queue.size, queue.pending);
        queue.clear();
        stream.end(err);
    };
    const onQueueJobComplete = (result) => {
        if (result != null) {
            stream.push(result);
        }
    };
    const onQueueError = (err) => {
        log('queue error', err);
        cleanup(err);
    };
    const onQueueIdle = () => {
        log('queue idle');
        cleanup();
    };
    // clear the queue and throw if the query is aborted
    const onSignalAbort = () => {
        log('abort queue');
        cleanup(new CodeError('Query aborted', 'ERR_QUERY_ABORTED'));
    };
    // the user broke out of the loop early, ensure we resolve the deferred result
    // promise and clear the queue of any remaining jobs
    const onCleanUp = () => {
        cleanup();
    };
    // add listeners
    queue.on('completed', onQueueJobComplete);
    queue.on('error', onQueueError);
    queue.on('idle', onQueueIdle);
    signal.addEventListener('abort', onSignalAbort);
    cleanUp.addEventListener('cleanup', onCleanUp);
    try {
        yield* stream;
    }
    finally {
        // remove listeners
        queue.removeListener('completed', onQueueJobComplete);
        queue.removeListener('error', onQueueError);
        queue.removeListener('idle', onQueueIdle);
        signal.removeEventListener('abort', onSignalAbort);
        cleanUp.removeEventListener('cleanup', onCleanUp);
    }
}
//# sourceMappingURL=utils.js.map