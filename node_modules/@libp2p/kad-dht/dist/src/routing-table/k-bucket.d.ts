import { TypedEventEmitter } from '@libp2p/interface/events';
import type { PeerId } from '@libp2p/interface/peer-id';
export interface PingEventDetails {
    oldContacts: Contact[];
    newContact: Contact;
}
export interface UpdatedEventDetails {
    incumbent: Contact;
    selection: Contact;
}
export interface KBucketEvents {
    'ping': CustomEvent<PingEventDetails>;
    'added': CustomEvent<Contact>;
    'removed': CustomEvent<Contact>;
    'updated': CustomEvent<UpdatedEventDetails>;
}
export interface KBucketOptions {
    /**
     * A Uint8Array representing the local node id
     */
    localNodeId: Uint8Array;
    /**
     * The number of nodes that a k-bucket can contain before being full or split.
     */
    numberOfNodesPerKBucket?: number;
    /**
     * The number of nodes to ping when a bucket that should not be split becomes
     * full. KBucket will emit a `ping` event that contains `numberOfNodesToPing`
     * nodes that have not been contacted the longest.
     */
    numberOfNodesToPing?: number;
    /**
     * An optional `distance` function that gets two `id` Uint8Arrays and return
     * distance (as number) between them.
     */
    distance?(a: Uint8Array, b: Uint8Array): number;
    /**
     * An optional `arbiter` function that given two `contact` objects with the
     * same `id` returns the desired object to be used for updating the k-bucket.
     * For more details, see [arbiter function](#arbiter-function).
     */
    arbiter?(incumbent: Contact, candidate: Contact): Contact;
}
export interface Contact {
    id: Uint8Array;
    peer: PeerId;
    vectorClock?: number;
}
export interface Bucket {
    id: Uint8Array;
    contacts: Contact[];
    dontSplit: boolean;
    left: Bucket;
    right: Bucket;
}
/**
 * Implementation of a Kademlia DHT k-bucket used for storing
 * contact (peer node) information.
 */
export declare class KBucket extends TypedEventEmitter<KBucketEvents> {
    localNodeId: Uint8Array;
    root: Bucket;
    private readonly numberOfNodesPerKBucket;
    private readonly numberOfNodesToPing;
    private readonly distance;
    private readonly arbiter;
    constructor(options: KBucketOptions);
    /**
     * Default arbiter function for contacts with the same id. Uses
     * contact.vectorClock to select which contact to update the k-bucket with.
     * Contact with larger vectorClock field will be selected. If vectorClock is
     * the same, candidate will be selected.
     *
     * @param {object} incumbent - Contact currently stored in the k-bucket.
     * @param {object} candidate - Contact being added to the k-bucket.
     * @returns {object} Contact to updated the k-bucket with.
     */
    static arbiter(incumbent: Contact, candidate: Contact): Contact;
    /**
     * Default distance function. Finds the XOR
     * distance between firstId and secondId.
     *
     * @param  {Uint8Array} firstId -  Uint8Array containing first id.
     * @param  {Uint8Array} secondId -  Uint8Array containing second id.
     * @returns {number} Integer The XOR distance between firstId and secondId.
     */
    static distance(firstId: Uint8Array, secondId: Uint8Array): number;
    /**
     * Adds a contact to the k-bucket.
     *
     * @param {object} contact - the contact object to add
     */
    add(contact: Contact): KBucket;
    /**
     * Get the n closest contacts to the provided node id. "Closest" here means:
     * closest according to the XOR metric of the contact node id.
     *
     * @param {Uint8Array} id - Contact node id
     * @param {number} n - Integer (Default: Infinity) The maximum number of closest contacts to return
     * @returns {Array} Array Maximum of n closest contacts to the node id
     */
    closest(id: Uint8Array, n?: number): Contact[];
    /**
     * Counts the total number of contacts in the tree.
     *
     * @returns {number} The number of contacts held in the tree
     */
    count(): number;
    /**
     * Determines whether the id at the bitIndex is 0 or 1.
     * Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise
     *
     * @param {object} node - internal object that has 2 leafs: left and right
     * @param {Uint8Array} id - Id to compare localNodeId with.
     * @param {number} bitIndex - Integer (Default: 0) The bit index to which bit to check in the id Uint8Array.
     * @returns {object} left leaf if id at bitIndex is 0, right leaf otherwise.
     */
    _determineNode(node: any, id: Uint8Array, bitIndex: number): Bucket;
    /**
     * Get a contact by its exact ID.
     * If this is a leaf, loop through the bucket contents and return the correct
     * contact if we have it or null if not. If this is an inner node, determine
     * which branch of the tree to traverse and repeat.
     *
     * @param {Uint8Array} id - The ID of the contact to fetch.
     * @returns {object | null} The contact if available, otherwise null
     */
    get(id: Uint8Array): Contact | undefined;
    /**
     * Returns the index of the contact with provided
     * id if it exists, returns -1 otherwise.
     *
     * @param {object} node - internal object that has 2 leafs: left and right
     * @param {Uint8Array} id - Contact node id.
     * @returns {number} Integer Index of contact with provided id if it exists, -1 otherwise.
     */
    _indexOf(node: Bucket, id: Uint8Array): number;
    /**
     * Removes contact with the provided id.
     *
     * @param {Uint8Array} id - The ID of the contact to remove
     * @returns {object} The k-bucket itself
     */
    remove(id: Uint8Array): KBucket;
    /**
     * Splits the node, redistributes contacts to the new nodes, and marks the
     * node that was split as an inner node of the binary tree of nodes by
     * setting this.root.contacts = null
     *
     * @param {object} node - node for splitting
     * @param {number} bitIndex - the bitIndex to which byte to check in the Uint8Array for navigating the binary tree
     */
    _split(node: Bucket, bitIndex: number): void;
    /**
     * Returns all the contacts contained in the tree as an array.
     * If this is a leaf, return a copy of the bucket. If this is not a leaf,
     * return the union of the low and high branches (themselves also as arrays).
     *
     * @returns {Array} All of the contacts in the tree, as an array
     */
    toArray(): Contact[];
    /**
     * Similar to `toArray()` but instead of buffering everything up into an
     * array before returning it, yields contacts as they are encountered while
     * walking the tree.
     *
     * @returns {Iterable} All of the contacts in the tree, as an iterable
     */
    toIterable(): Iterable<Contact>;
    /**
     * Updates the contact selected by the arbiter.
     * If the selection is our old contact and the candidate is some new contact
     * then the new contact is abandoned (not added).
     * If the selection is our old contact and the candidate is our old contact
     * then we are refreshing the contact and it is marked as most recently
     * contacted (by being moved to the right/end of the bucket array).
     * If the selection is our new contact, the old contact is removed and the new
     * contact is marked as most recently contacted.
     *
     * @param {object} node - internal object that has 2 leafs: left and right
     * @param {number} index - the index in the bucket where contact exists (index has already been computed in a previous calculation)
     * @param {object} contact - The contact object to update
     */
    _update(node: Bucket, index: number, contact: Contact): void;
}
//# sourceMappingURL=k-bucket.d.ts.map