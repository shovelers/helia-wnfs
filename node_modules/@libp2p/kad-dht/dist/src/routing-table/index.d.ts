import { TypedEventEmitter } from '@libp2p/interface/events';
import Queue from 'p-queue';
import { KBucket, type PingEventDetails } from './k-bucket.js';
import type { Metrics } from '@libp2p/interface/metrics';
import type { PeerId } from '@libp2p/interface/peer-id';
import type { PeerStore } from '@libp2p/interface/peer-store';
import type { Startable } from '@libp2p/interface/startable';
import type { ConnectionManager } from '@libp2p/interface-internal/connection-manager';
export declare const KAD_CLOSE_TAG_NAME = "kad-close";
export declare const KAD_CLOSE_TAG_VALUE = 50;
export declare const KBUCKET_SIZE = 20;
export declare const PING_TIMEOUT = 10000;
export declare const PING_CONCURRENCY = 10;
export interface RoutingTableInit {
    lan: boolean;
    protocol: string;
    kBucketSize?: number;
    pingTimeout?: number;
    pingConcurrency?: number;
    tagName?: string;
    tagValue?: number;
}
export interface RoutingTableComponents {
    peerId: PeerId;
    peerStore: PeerStore;
    connectionManager: ConnectionManager;
    metrics?: Metrics;
}
export interface RoutingTableEvents {
    'peer:add': CustomEvent<PeerId>;
    'peer:remove': CustomEvent<PeerId>;
}
/**
 * A wrapper around `k-bucket`, to provide easy store and
 * retrieval for peers.
 */
export declare class RoutingTable extends TypedEventEmitter<RoutingTableEvents> implements Startable {
    kBucketSize: number;
    kb?: KBucket;
    pingQueue: Queue;
    private readonly log;
    private readonly components;
    private readonly lan;
    private readonly pingTimeout;
    private readonly pingConcurrency;
    private running;
    private readonly protocol;
    private readonly tagName;
    private readonly tagValue;
    private metrics?;
    constructor(components: RoutingTableComponents, init: RoutingTableInit);
    isStarted(): boolean;
    start(): Promise<void>;
    stop(): Promise<void>;
    /**
     * Keep track of our k-closest peers and tag them in the peer store as such
     * - this will lower the chances that connections to them get closed when
     * we reach connection limits
     */
    _tagPeers(kBuck: KBucket): void;
    /**
     * Called on the `ping` event from `k-bucket` when a bucket is full
     * and cannot split.
     *
     * `oldContacts.length` is defined by the `numberOfNodesToPing` param
     * passed to the `k-bucket` constructor.
     *
     * `oldContacts` will not be empty and is the list of contacts that
     * have not been contacted for the longest.
     */
    _onPing(evt: CustomEvent<PingEventDetails>): void;
    /**
     * Amount of currently stored peers
     */
    get size(): number;
    /**
     * Find a specific peer by id
     */
    find(peer: PeerId): Promise<PeerId | undefined>;
    /**
     * Retrieve the closest peers to the given key
     */
    closestPeer(key: Uint8Array): PeerId | undefined;
    /**
     * Retrieve the `count`-closest peers to the given key
     */
    closestPeers(key: Uint8Array, count?: number): PeerId[];
    /**
     * Add or update the routing table with the given peer
     */
    add(peer: PeerId): Promise<void>;
    /**
     * Remove a given peer from the table
     */
    remove(peer: PeerId): Promise<void>;
}
//# sourceMappingURL=index.d.ts.map