import os from 'os';
import { TypedEventEmitter, CustomEvent } from '@libp2p/interface';
import { ipPortToMultiaddr as toMultiaddr } from '@libp2p/utils/ip-port-to-multiaddr';
import { multiaddr, protocols } from '@multiformats/multiaddr';
import { createServer } from 'it-ws/server';
import { socketToMaConn } from './socket-to-conn.js';
class WebSocketListener extends TypedEventEmitter {
    connections;
    listeningMultiaddr;
    server;
    log;
    constructor(components, init) {
        super();
        this.log = components.logger.forComponent('libp2p:websockets:listener');
        // Keep track of open connections to destroy when the listener is closed
        this.connections = new Set();
        const self = this; // eslint-disable-line @typescript-eslint/no-this-alias
        this.server = createServer({
            ...init,
            onConnection: (stream) => {
                const maConn = socketToMaConn(stream, toMultiaddr(stream.remoteAddress ?? '', stream.remotePort ?? 0), {
                    logger: components.logger
                });
                this.log('new inbound connection %s', maConn.remoteAddr);
                this.connections.add(stream);
                stream.socket.on('close', function () {
                    self.connections.delete(stream);
                });
                try {
                    void init.upgrader.upgradeInbound(maConn)
                        .then((conn) => {
                        this.log('inbound connection %s upgraded', maConn.remoteAddr);
                        if (init?.handler != null) {
                            init?.handler(conn);
                        }
                        self.dispatchEvent(new CustomEvent('connection', {
                            detail: conn
                        }));
                    })
                        .catch(async (err) => {
                        this.log.error('inbound connection failed to upgrade', err);
                        await maConn.close().catch(err => {
                            this.log.error('inbound connection failed to close after upgrade failed', err);
                        });
                    });
                }
                catch (err) {
                    this.log.error('inbound connection failed to upgrade', err);
                    maConn.close().catch(err => {
                        this.log.error('inbound connection failed to close after upgrade failed', err);
                    });
                }
            }
        });
        this.server.on('listening', () => {
            this.dispatchEvent(new CustomEvent('listening'));
        });
        this.server.on('error', (err) => {
            this.dispatchEvent(new CustomEvent('error', {
                detail: err
            }));
        });
        this.server.on('close', () => {
            this.dispatchEvent(new CustomEvent('close'));
        });
    }
    async close() {
        await Promise.all(Array.from(this.connections).map(async (maConn) => { await maConn.close(); }));
        if (this.server.address() == null) {
            // not listening, close will throw an error
            return;
        }
        await this.server.close();
    }
    async listen(ma) {
        this.listeningMultiaddr = ma;
        await this.server.listen(ma.toOptions());
    }
    getAddrs() {
        const multiaddrs = [];
        const address = this.server.address();
        if (address == null) {
            throw new Error('Listener is not ready yet');
        }
        if (typeof address === 'string') {
            throw new Error('Wrong address type received - expected AddressInfo, got string - are you trying to listen on a unix socket?');
        }
        if (this.listeningMultiaddr == null) {
            throw new Error('Listener is not ready yet');
        }
        const ipfsId = this.listeningMultiaddr.getPeerId();
        const protos = this.listeningMultiaddr.protos();
        // Because TCP will only return the IPv6 version
        // we need to capture from the passed multiaddr
        if (protos.some(proto => proto.code === protocols('ip4').code)) {
            const wsProto = protos.some(proto => proto.code === protocols('ws').code) ? '/ws' : '/wss';
            let m = this.listeningMultiaddr.decapsulate('tcp');
            m = m.encapsulate(`/tcp/${address.port}${wsProto}`);
            if (ipfsId != null) {
                m = m.encapsulate(`/p2p/${ipfsId}`);
            }
            if (m.toString().includes('0.0.0.0')) {
                const netInterfaces = os.networkInterfaces();
                Object.values(netInterfaces).forEach(niInfos => {
                    if (niInfos == null) {
                        return;
                    }
                    niInfos.forEach(ni => {
                        if (ni.family === 'IPv4') {
                            multiaddrs.push(multiaddr(m.toString().replace('0.0.0.0', ni.address)));
                        }
                    });
                });
            }
            else {
                multiaddrs.push(m);
            }
        }
        return multiaddrs;
    }
}
export function createListener(components, init) {
    return new WebSocketListener(components, init);
}
//# sourceMappingURL=listener.js.map