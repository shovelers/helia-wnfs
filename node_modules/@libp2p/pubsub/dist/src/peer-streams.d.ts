import { TypedEventEmitter } from '@libp2p/interface/events';
import { Uint8ArrayList } from 'uint8arraylist';
import type { Stream } from '@libp2p/interface/connection';
import type { PeerId } from '@libp2p/interface/peer-id';
import type { PeerStreamEvents } from '@libp2p/interface/pubsub';
import type { Pushable } from 'it-pushable';
export interface PeerStreamsInit {
    id: PeerId;
    protocol: string;
}
/**
 * Thin wrapper around a peer's inbound / outbound pubsub streams
 */
export declare class PeerStreams extends TypedEventEmitter<PeerStreamEvents> {
    readonly id: PeerId;
    readonly protocol: string;
    /**
     * Write stream - it's preferable to use the write method
     */
    outboundStream?: Pushable<Uint8ArrayList>;
    /**
     * Read stream
     */
    inboundStream?: AsyncIterable<Uint8ArrayList>;
    /**
     * The raw outbound stream, as retrieved from conn.newStream
     */
    private _rawOutboundStream?;
    /**
     * The raw inbound stream, as retrieved from the callback from libp2p.handle
     */
    private _rawInboundStream?;
    /**
     * An AbortController for controlled shutdown of the inbound stream
     */
    private readonly _inboundAbortController;
    private closed;
    constructor(init: PeerStreamsInit);
    /**
     * Do we have a connection to read from?
     */
    get isReadable(): boolean;
    /**
     * Do we have a connection to write on?
     */
    get isWritable(): boolean;
    /**
     * Send a message to this peer.
     * Throws if there is no `stream` to write to available.
     */
    write(data: Uint8Array | Uint8ArrayList): void;
    /**
     * Attach a raw inbound stream and setup a read stream
     */
    attachInboundStream(stream: Stream): AsyncIterable<Uint8ArrayList>;
    /**
     * Attach a raw outbound stream and setup a write stream
     */
    attachOutboundStream(stream: Stream): Promise<Pushable<Uint8ArrayList>>;
    /**
     * Closes the open connection to peer
     */
    close(): void;
}
//# sourceMappingURL=peer-streams.d.ts.map