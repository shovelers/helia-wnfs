/**
 * @packageDocumentation
 *
 * - Manages the lifecycle of a key
 * - Keys are encrypted at rest
 * - Enforces the use of safe key names
 * - Uses encrypted PKCS 8 for key storage
 * - Uses PBKDF2 for a "stetched" key encryption key
 * - Enforces NIST SP 800-131A and NIST SP 800-132
 * - Delays reporting errors to slow down brute force attacks
 *
 * ## KeyInfo
 *
 * The key management and naming service API all return a `KeyInfo` object.  The `id` is a universally unique identifier for the key.  The `name` is local to the key chain.
 *
 * ```js
 * {
 *   name: 'rsa-key',
 *   id: 'QmYWYSUZ4PV6MRFYpdtEDJBiGs4UrmE6g8wmAWSePekXVW'
 * }
 * ```
 *
 * The **key id** is the SHA-256 [multihash](https://github.com/multiformats/multihash) of its public key.
 *
 * The *public key* is a [protobuf encoding](https://github.com/libp2p/js-libp2p-crypto/blob/master/src/keys/keys.proto.js) containing a type and the [DER encoding](https://en.wikipedia.org/wiki/X.690) of the PKCS [SubjectPublicKeyInfo](https://www.ietf.org/rfc/rfc3279.txt).
 *
 * ## Private key storage
 *
 * A private key is stored as an encrypted PKCS 8 structure in the PEM format. It is protected by a key generated from the key chain's *passPhrase* using **PBKDF2**.
 *
 * The default options for generating the derived encryption key are in the `dek` object.  This, along with the passPhrase, is the input to a `PBKDF2` function.
 *
 * ```js
 * const defaultOptions = {
 * // See https://cryptosense.com/parameter-choice-for-pbkdf2/
 *   dek: {
 *     keyLength: 512 / 8,
 *     iterationCount: 1000,
 *     salt: 'at least 16 characters long',
 *     hash: 'sha2-512'
 *   }
 * }
 * ```
 * ![key storage](./doc/private-key.png?raw=true)
 *
 * ## Physical storage
 *
 * The actual physical storage of an encrypted key is left to implementations of [interface-datastore](https://github.com/ipfs/interface-datastore/).
 *
 * A key benefit is that now the key chain can be used in browser with the [js-datastore-level](https://github.com/ipfs/js-datastore-level) implementation.
 */
import type { KeyChain, KeyInfo } from '@libp2p/interface/keychain';
import type { KeyType } from '@libp2p/interface/keys';
import type { PeerId } from '@libp2p/interface/peer-id';
import type { Datastore } from 'interface-datastore';
export interface DEKConfig {
    hash: string;
    salt: string;
    iterationCount: number;
    keyLength: number;
}
export interface KeyChainInit {
    pass?: string;
    dek?: DEKConfig;
}
declare const defaultOptions: {
    dek: {
        keyLength: number;
        iterationCount: number;
        salt: string;
        hash: string;
    };
};
export interface KeyChainComponents {
    datastore: Datastore;
}
/**
 * Manages the lifecycle of a key. Keys are encrypted at rest using PKCS #8.
 *
 * A key in the store has two entries
 * - '/info/*key-name*', contains the KeyInfo for the key
 * - '/pkcs8/*key-name*', contains the PKCS #8 for the key
 *
 */
export declare class DefaultKeyChain implements KeyChain {
    private readonly components;
    private readonly init;
    /**
     * Creates a new instance of a key chain
     */
    constructor(components: KeyChainComponents, init: KeyChainInit);
    /**
     * Generates the options for a keychain.  A random salt is produced.
     *
     * @returns {object}
     */
    static generateOptions(): KeyChainInit;
    /**
     * Gets an object that can encrypt/decrypt protected data.
     * The default options for a keychain.
     *
     * @returns {object}
     */
    static get options(): typeof defaultOptions;
    /**
     * Create a new key.
     *
     * @param {string} name - The local key name; cannot already exist.
     * @param {string} type - One of the key types; 'rsa'.
     * @param {number} [size = 2048] - The key size in bits. Used for rsa keys only
     */
    createKey(name: string, type: KeyType, size?: number): Promise<KeyInfo>;
    /**
     * List all the keys.
     *
     * @returns {Promise<KeyInfo[]>}
     */
    listKeys(): Promise<KeyInfo[]>;
    /**
     * Find a key by it's id
     */
    findKeyById(id: string): Promise<KeyInfo>;
    /**
     * Find a key by it's name.
     *
     * @param {string} name - The local key name.
     * @returns {Promise<KeyInfo>}
     */
    findKeyByName(name: string): Promise<KeyInfo>;
    /**
     * Remove an existing key.
     *
     * @param {string} name - The local key name; must already exist.
     * @returns {Promise<KeyInfo>}
     */
    removeKey(name: string): Promise<KeyInfo>;
    /**
     * Rename a key
     *
     * @param {string} oldName - The old local key name; must already exist.
     * @param {string} newName - The new local key name; must not already exist.
     * @returns {Promise<KeyInfo>}
     */
    renameKey(oldName: string, newName: string): Promise<KeyInfo>;
    /**
     * Export an existing key as a PEM encrypted PKCS #8 string
     */
    exportKey(name: string, password: string): Promise<string>;
    /**
     * Export an existing key as a PeerId
     */
    exportPeerId(name: string): Promise<PeerId>;
    /**
     * Import a new key from a PEM encoded PKCS #8 string
     *
     * @param {string} name - The local key name; must not already exist.
     * @param {string} pem - The PEM encoded PKCS #8 string
     * @param {string} password - The password.
     * @returns {Promise<KeyInfo>}
     */
    importKey(name: string, pem: string, password: string): Promise<KeyInfo>;
    /**
     * Import a peer key
     */
    importPeer(name: string, peer: PeerId): Promise<KeyInfo>;
    /**
     * Gets the private key as PEM encoded PKCS #8 string
     */
    getPrivateKey(name: string): Promise<string>;
    /**
     * Rotate keychain password and re-encrypt all associated keys
     */
    rotateKeychainPass(oldPass: string, newPass: string): Promise<void>;
}
export {};
//# sourceMappingURL=index.d.ts.map