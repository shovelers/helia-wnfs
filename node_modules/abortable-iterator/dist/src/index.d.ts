/**
 * @packageDocumentation
 *
 * @example
 *
 * ```js
 * import { abortableSource } from 'abortable-iterator'
 *
 * async function main () {
 *   // An example function that creates an async iterator that yields an increasing
 *   // number every x milliseconds and NEVER ENDS!
 *   const asyncCounter = async function * (start, delay) {
 *     let i = start
 *     while (true) {
 *       yield new Promise(resolve => setTimeout(() => resolve(i++), delay))
 *     }
 *   }
 *
 *   // Create a counter that'll yield numbers from 0 upwards every second
 *   const everySecond = asyncCounter(0, 1000)
 *
 *   // Make everySecond abortable!
 *   const controller = new AbortController()
 *   const abortableEverySecond = abortableSource(everySecond, controller.signal)
 *
 *   // Abort after 5 seconds
 *   setTimeout(() => controller.abort(), 5000)
 *
 *   try {
 *     // Start the iteration, which will throw after 5 seconds when it is aborted
 *     for await (const n of abortableEverySecond) {
 *       console.log(n)
 *     }
 *   } catch (err) {
 *     if (err.code === 'ERR_ABORTED') {
 *       // Expected - all ok :D
 *     } else {
 *       throw err
 *     }
 *   }
 * }
 *
 * main()
 * ```
 */
import { AbortError } from './abort-error.js';
import type { Duplex, Source, Sink } from 'it-stream-types';
export interface Options<T> {
    onReturnError?: (err: Error) => void;
    onAbort?: (source: Source<T>) => void;
    abortMessage?: string;
    abortCode?: string;
    returnOnAbort?: boolean;
}
/**
 * Wrap an iterator to make it abortable, allow cleanup when aborted via onAbort
 */
export declare function abortableSource<T>(source: Source<T>, signal: AbortSignal, options?: Options<T>): AsyncGenerator<T>;
export declare function abortableSink<T, R = Promise<void>>(sink: Sink<AsyncIterable<T>, R>, signal: AbortSignal, options?: Options<T>): Sink<Source<T>, R>;
export declare function abortableDuplex<TSource, TSink = TSource, RSink = Promise<void>>(duplex: Duplex<AsyncIterable<TSource>, Source<TSink>, RSink>, signal: AbortSignal, options?: Options<TSource>): Duplex<AsyncGenerator<TSource>, Source<TSink>, RSink>;
export { AbortError };
export { abortableSink as abortableTransform };
//# sourceMappingURL=index.d.ts.map